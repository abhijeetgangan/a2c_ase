{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"a2c_ase","text":"<p>An ASE-friendly implementation of the amorphous-to-crystalline (a2c) workflow for predicting crystal emergence from amorphous precursors using machine learning interatomic potentials.</p>"},{"location":"#overview","title":"Overview","text":"<p>The a2c workflow predicts crystalline structures from amorphous materials through:</p> <ul> <li>Melt-quench molecular dynamics simulations</li> <li>Systematic subcell extraction and optimization</li> <li>Structure validation and space group analysis</li> </ul> <p>Learn more: Workflow Guide</p>"},{"location":"#getting-started","title":"Getting Started","text":"<ul> <li>Installation</li> <li>Quick Start</li> <li>Examples</li> </ul>"},{"location":"#references","title":"References","text":"<ol> <li> <p>Aykol, M., Merchant, A., Batzner, S. et al. Predicting emergence of crystals from amorphous precursors with deep learning potentials. Nat Comput Sci 5, 105\u2013111 (2025). DOI: 10.1038/s43588-024-00752-y</p> </li> <li> <p>Reference implementation: a2c-workflow</p> </li> </ol>"},{"location":"api/potentials/","title":"Potentials","text":"<p>Built-in interatomic potential calculators.</p>"},{"location":"api/potentials/#a2c_ase.potentials.soft_sphere.SoftSphere","title":"SoftSphere","text":"<pre><code>SoftSphere(**kwargs: Any)\n</code></pre> <p>               Bases: <code>Calculator</code></p> <p>Soft sphere potential calculator for purely repulsive interactions.</p> <p>Implements a soft repulsive potential used for structure generation and packing optimization. The potential is zero when r &gt;= sigma and purely repulsive for r &lt; sigma.</p> <p>Attributes:</p> Name Type Description <code>implemented_properties</code> <code>list of str</code> <p>Calculable properties: energy, energies, forces, free_energy, stress, stresses</p> <code>default_parameters</code> <code>dict</code> <p>Default values: sigma=1.0, epsilon=1.0, alpha=2, skin=0.2</p> Notes <p>The pairwise energy is \\(u_{ij} = \\frac{\\epsilon}{\\alpha}\\) times \\(\\left(1 - \\frac{r_{ij}}{\\sigma}\\right)^{\\alpha}\\) for \\(r_{ij} &lt; \\sigma\\). Energy partitioning uses symmetric approach with bothways=True neighbor list. Implementation based on JAX-MD (https://github.com/google/jax-md).</p> <p>Initialize the SoftSphere calculator with the given parameters.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>dict</code> <p>Calculator parameters. Supported parameters:</p> <ul> <li>sigma (float): Particle diameter, default: 1.0</li> <li>epsilon (float): Interaction energy scale, default: 1.0</li> <li>alpha (float): Exponent specifying interaction stiffness, default: 2</li> <li>skin (float): Skin parameter for neighbor list, default: 0.2</li> </ul> <code>{}</code>"},{"location":"api/potentials/#a2c_ase.potentials.soft_sphere.SoftSphere-functions","title":"Functions","text":""},{"location":"api/potentials/#a2c_ase.potentials.soft_sphere.SoftSphere.calculate","title":"calculate","text":"<pre><code>calculate(atoms: Optional[Atoms] = None, properties: Optional[list[str]] = None, system_changes: list[str] = all_changes) -&gt; None\n</code></pre> <p>Calculate energy, forces and stress using soft sphere potential.</p> <p>Parameters:</p> Name Type Description Default <code>atoms</code> <code>Atoms</code> <p>ASE Atoms object containing atomic positions and cell</p> <code>None</code> <code>properties</code> <code>list of str</code> <p>Properties to calculate. If None, calculates all implemented properties</p> <code>None</code> <code>system_changes</code> <code>list of str</code> <p>List of changes since last calculation</p> <code>all_changes</code>"},{"location":"api/potentials/#a2c_ase.potentials.mlj.MultiLennardJones","title":"MultiLennardJones","text":"<pre><code>MultiLennardJones(**kwargs)\n</code></pre> <p>               Bases: <code>Calculator</code></p> <p>Multi-species Lennard-Jones potential calculator.</p> <p>Implements the classic 12-6 Lennard-Jones potential with support for multiple chemical species, mixing rules, and custom cross-interactions.</p> <p>Attributes:</p> Name Type Description <code>implemented_properties</code> <code>list of str</code> <p>Calculable properties: energy, energies, forces, free_energy, stress, stresses</p> <code>default_parameters</code> <code>dict</code> <p>Default values: epsilon=1.0, sigma=1.0, rc=None, ro=None, smooth=False, mixing_rule='lorentz_berthelot', cross_interactions=None</p> Notes <p>The 12-6 Lennard-Jones potential between atoms i and j. Energy: \\(u_{ij}(r) = 4\\epsilon_{ij}[(\\sigma_{ij}/r)^{12} - (\\sigma_{ij}/r)^6]\\). See https://en.wikipedia.org/wiki/Lennard-Jones_potential for details.</p> <p>Initialize Multi-Lennard-Jones calculator.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>dict</code> <p>Calculator parameters. Supported parameters:</p> <ul> <li>sigma (float, dict, or array-like): Zero-crossing distance.   Default 1.0. Can be uniform float, dict mapping symbols to values,   or array indexed by atomic number.</li> <li>epsilon (float, dict, or array-like): Well depth. Default 1.0.   Can be uniform float, dict mapping symbols to values,   or array indexed by atomic number.</li> <li>rc (float, optional): Cutoff distance.   Default None (auto: 3 * max(sigma)).</li> <li>ro (float, optional): Smooth cutoff onset distance.   Default None (auto: 0.66 * rc).</li> <li>smooth (bool): Use smooth cutoff function. Default False.</li> <li>mixing_rule (str): Mixing rule for cross-species.   Default 'lorentz_berthelot'. Options: 'lorentz_berthelot' or 'geometric'.</li> <li>cross_interactions (dict, optional): Explicit cross-interaction parameters.   Format: {('A', 'B'): {'sigma': value, 'epsilon': value}}.</li> </ul> <code>{}</code>"},{"location":"api/potentials/#a2c_ase.potentials.mlj.MultiLennardJones-functions","title":"Functions","text":""},{"location":"api/potentials/#a2c_ase.potentials.mlj.MultiLennardJones.calculate","title":"calculate","text":"<pre><code>calculate(atoms=None, properties=None, system_changes=all_changes)\n</code></pre> <p>Calculate energy, forces and stress using Lennard-Jones potential.</p> <p>Parameters:</p> Name Type Description Default <code>atoms</code> <code>Atoms</code> <p>ASE Atoms object containing atomic positions and cell</p> <code>None</code> <code>properties</code> <code>list of str</code> <p>Properties to calculate. If None, calculates all implemented properties</p> <code>None</code> <code>system_changes</code> <code>list of str</code> <p>List of changes since last calculation</p> <code>all_changes</code>"},{"location":"api/potentials/#a2c_ase.potentials.mlj.cutoff_function","title":"cutoff_function","text":"<pre><code>cutoff_function(r: ndarray, rc: float, ro: float) -&gt; np.ndarray\n</code></pre> <p>Smooth cutoff function for Lennard-Jones potential.</p> <p>Goes from 1 to 0 between ro and rc, ensuring that u(r) = lj(r) * cutoff_function(r) is continuously differentiable (C^1). Defined as 1 below ro, 0 above rc.</p> <p>Parameters:</p> Name Type Description Default <code>r</code> <code>float or ndarray</code> <p>Squared distance r_ij^2</p> required <code>rc</code> <code>float</code> <p>Squared cutoff distance</p> required <code>ro</code> <code>float</code> <p>Squared onset distance for cutoff</p> required <p>Returns:</p> Type Description <code>float or ndarray</code> <p>Cutoff function value(s)</p> Notes <p>All distances (r, rc, ro) are expected to be squared. Taken from https://github.com/google/jax-md.</p>"},{"location":"api/potentials/#a2c_ase.potentials.mlj.d_cutoff_function","title":"d_cutoff_function","text":"<pre><code>d_cutoff_function(r: ndarray, rc: float, ro: float) -&gt; np.ndarray\n</code></pre> <p>Derivative of smooth cutoff function with respect to r.</p> <p>Parameters:</p> Name Type Description Default <code>r</code> <code>float or ndarray</code> <p>Squared distance r_ij^2</p> required <code>rc</code> <code>float</code> <p>Squared cutoff distance</p> required <code>ro</code> <code>float</code> <p>Squared onset distance for cutoff</p> required <p>Returns:</p> Type Description <code>float or ndarray</code> <p>Derivative of cutoff function</p> Notes <p>Since r = r_ij^2, for the derivative with respect to r_ij, multiply by 2*r_ij. The factor of 2 appears naturally, and r_ij cancels when converting from scalar distance to distance vector (d r_ij / d d_ij).</p>"},{"location":"api/runner/","title":"Runner","text":"<p>High-level functions for molecular dynamics simulations and structure optimization.</p>"},{"location":"api/runner/#a2c_ase.runner.melt_quench_md","title":"melt_quench_md","text":"<pre><code>melt_quench_md(atoms, calculator: Calculator, *, equi_steps: int = 2500, cool_steps: int = 2500, final_steps: int = 2500, T_high: float = 2000.0, T_low: float = 300.0, time_step: float = 2.0, friction: float = 0.01, trajectory_file: str | None = None, seed: int = 42, verbose: bool = True, log_interval: int = 100)\n</code></pre> <p>Run melt-quench molecular dynamics to generate amorphous structures.</p> <p>Performs a three-stage MD simulation: 1. High-temperature equilibration to melt the structure 2. Controlled cooling to quench the liquid 3. Low-temperature equilibration to relax the structure</p> <p>Parameters:</p> Name Type Description Default <code>atoms</code> <code>Atoms</code> <p>ASE Atoms object with initial atomic structure</p> required <code>calculator</code> <code>Calculator</code> <p>ASE calculator for computing forces and energies</p> required <code>equi_steps</code> <code>int</code> <p>Number of steps for high-temperature equilibration</p> <code>2500</code> <code>cool_steps</code> <code>int</code> <p>Number of steps for cooling phase</p> <code>2500</code> <code>final_steps</code> <code>int</code> <p>Number of steps for final low-temperature equilibration</p> <code>2500</code> <code>T_high</code> <code>float</code> <p>High temperature for melting phase (K)</p> <code>2000.0</code> <code>T_low</code> <code>float</code> <p>Low temperature for final phase (K)</p> <code>300.0</code> <code>time_step</code> <code>float</code> <p>MD time step (fs)</p> <code>2.0</code> <code>friction</code> <code>float</code> <p>Langevin friction parameter (atomic units)</p> <code>0.01</code> <code>trajectory_file</code> <code>str</code> <p>Path to save MD trajectory</p> <code>None</code> <code>seed</code> <code>int</code> <p>Random seed for reproducibility</p> <code>42</code> <code>verbose</code> <code>bool</code> <p>Whether to print progress information</p> <code>True</code> <code>log_interval</code> <code>int</code> <p>Number of steps between progress logs</p> <code>100</code> <p>Returns:</p> Name Type Description <code>atoms</code> <code>Atoms</code> <p>ASE Atoms with final amorphous structure</p> <code>log_data</code> <code>dict</code> <p>Dictionary with temperature and energy trajectories</p>"},{"location":"api/runner/#a2c_ase.runner.relax_unit_cell","title":"relax_unit_cell","text":"<pre><code>relax_unit_cell(atoms: Atoms, calculator: Calculator, *, max_iter: int = 200, fmax: float = 0.01, trajectory_file: str | None = None, verbose: bool = True) -&gt; tuple[Atoms, dict]\n</code></pre> <p>Relax atomic positions and cell parameters using FIRE optimization.</p> <p>Performs simultaneous optimization of atomic positions and unit cell parameters using the Fast Inertial Relaxation Engine (FIRE) algorithm. The cell optimization is handled through ASE's FrechetCellFilter.</p> <p>Parameters:</p> Name Type Description Default <code>atoms</code> <code>Atoms</code> <p>ASE Atoms object containing atomic positions, species and cell information</p> required <code>calculator</code> <code>Calculator</code> <p>ASE calculator for computing energies, forces and stresses</p> required <code>max_iter</code> <code>int</code> <p>Maximum FIRE iterations, by default 200</p> <code>200</code> <code>fmax</code> <code>float</code> <p>Force convergence criterion in eV/\u00c5, by default 0.01</p> <code>0.01</code> <code>trajectory_file</code> <code>str</code> <p>Path to save optimization trajectory, by default None</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>Print optimization progress, by default True</p> <code>True</code> <p>Returns:</p> Type Description <code>tuple[Atoms, dict]</code> <ul> <li>Relaxed Atoms object with optimized positions and cell</li> <li>Dictionary containing energy, forces, stress and volume trajectories</li> </ul> Notes <p>The calculator must support stress tensor calculations. Periodic boundary conditions must be enabled on the Atoms object.</p>"},{"location":"api/utils/","title":"Utils","text":"<p>Utility functions for structure generation, manipulation, and analysis.</p>"},{"location":"api/utils/#a2c_ase.utils.random_packed_structure","title":"random_packed_structure","text":"<pre><code>random_packed_structure(composition: Composition, cell: ndarray, *, seed: int = 42, diameter: Optional[float] = None, auto_diameter: bool = False, max_iter: int = 100, fmax: float = 0.01, distance_tolerance: float = 0.0001, trajectory_file: Optional[str] = None, verbose: bool = True) -&gt; tuple[Atoms, Optional[list[dict]]]\n</code></pre> <p>Generate a random packed atomic structure with minimal atomic overlaps.</p> <p>Parameters:</p> Name Type Description Default <code>composition</code> <code>Composition</code> <p>Pymatgen Composition object specifying atomic composition (e.g. Fe80B20). Numbers indicate actual atom counts.</p> required <code>cell</code> <code>ndarray</code> <p>3x3 array defining triclinic simulation box in Angstroms.</p> required <code>seed</code> <code>int</code> <p>Random seed for reproducible generation, by default 42. If None, uses random initialization.</p> <code>42</code> <code>diameter</code> <code>float</code> <p>Minimum allowed interatomic distance for overlap detection. Used for soft-sphere potential, by default None.</p> <code>None</code> <code>auto_diameter</code> <code>bool</code> <p>If True, automatically calculate diameter from atomic radii, by default False.</p> <code>False</code> <code>max_iter</code> <code>int</code> <p>Maximum FIRE optimization steps to minimize overlaps, by default 100.</p> <code>100</code> <code>fmax</code> <code>float</code> <p>Maximum force criterion for convergence in eV/\u00c5, by default 0.01.</p> <code>0.01</code> <code>distance_tolerance</code> <code>float</code> <p>Distance threshold for considering atoms at same position, by default 0.0001.</p> <code>0.0001</code> <code>trajectory_file</code> <code>str</code> <p>Path to save optimization trajectory (.traj format), by default None.</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>Print progress information during optimization, by default True.</p> <code>True</code> <p>Returns:</p> Type Description <code>tuple[Atoms, Optional[list[dict]]]</code> <ul> <li>ASE Atoms object with optimized positions</li> <li>Optimization log if verbose=True, otherwise None</li> </ul>"},{"location":"api/utils/#a2c_ase.utils.get_diameter","title":"get_diameter","text":"<pre><code>get_diameter(composition: Composition) -&gt; float\n</code></pre> <p>Calculate characteristic atomic diameter for a chemical composition.</p> <p>Parameters:</p> Name Type Description Default <code>composition</code> <code>Composition</code> <p>Pymatgen Composition object specifying the chemical formula.</p> required <p>Returns:</p> Type Description <code>float</code> <p>Estimated minimum atomic diameter in Angstroms.</p> Notes <p>For multi-element compositions, calculates minimum possible interatomic distance by: - Using ionic radii for each element - Finding minimum sum of radii across all element pairs</p> <p>For single elements: - Uses metallic radius for metals - Uses atomic radius for non-metals, falling back to ionic radius if needed - Returns twice the radius as diameter</p>"},{"location":"api/utils/#a2c_ase.utils.extract_crystallizable_subcells","title":"extract_crystallizable_subcells","text":"<pre><code>extract_crystallizable_subcells(atoms: Atoms, *, d_frac: float = 0.2, n_min: int = 2, n_max: int = 8, cubic_only: bool = True, allowed_atom_counts: Optional[list[int]] = None, filter_function: Optional[Callable] = None, restrict_to_compositions: Optional[Sequence[str]] = None, max_coeff: Optional[int] = None, elements: Optional[Sequence[str]] = None) -&gt; list[Atoms]\n</code></pre> <p>Extract and filter subcells from an amorphous structure for crystallization analysis.</p> <p>Divides an amorphous structure into overlapping subcells and filters them based on shape criteria and atom count to identify potential crystalline structural motifs.</p> <p>Parameters:</p> Name Type Description Default <code>atoms</code> <code>Atoms</code> <p>ASE Atoms object representing the amorphous structure</p> required <code>d_frac</code> <code>float</code> <p>Grid spacing in fractional coordinates for subcell division, by default 0.2</p> <code>0.2</code> <code>n_min</code> <code>int</code> <p>Minimum number of atoms required in a subcell, by default 2</p> <code>2</code> <code>n_max</code> <code>int</code> <p>Maximum number of atoms allowed in a subcell, by default 8</p> <code>8</code> <code>cubic_only</code> <code>bool</code> <p>If True, only keep subcells where all dimensions are equal, by default True</p> <code>True</code> <code>allowed_atom_counts</code> <code>list[int]</code> <p>If provided, only keep subcells with these atom counts, by default None</p> <code>None</code> <code>filter_function</code> <code>callable</code> <p>Custom filter function that takes a subcell tuple (indices, lower_bound, upper_bound) and returns a boolean. If provided, used instead of default filter, by default None</p> <code>None</code> <code>restrict_to_compositions</code> <code>Sequence[str]</code> <p>Chemical formulas to filter subcells by (e.g. [\"AB\", \"AB2\"]). Only matching compositions are returned.</p> <code>None</code> <code>max_coeff</code> <code>int</code> <p>Maximum stoichiometric coefficient for auto-generating restrictions. E.g. max_coeff=2 allows AB2 but not AB3.</p> <code>None</code> <code>elements</code> <code>Sequence[str]</code> <p>Elements for generating stoichiometries. Required if max_coeff provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[Atoms]</code> <p>List of ASE Atoms objects representing the filtered subcells</p>"},{"location":"api/utils/#a2c_ase.utils.get_subcells_to_crystallize","title":"get_subcells_to_crystallize","text":"<pre><code>get_subcells_to_crystallize(fractional_positions: ndarray, species: list[str], d_frac: float = 0.05, n_min: int = 1, n_max: int = 48, restrict_to_compositions: Optional[Sequence[str]] = None, max_coeff: Optional[int] = None, elements: Optional[Sequence[str]] = None) -&gt; list[tuple[np.ndarray, np.ndarray, np.ndarray]]\n</code></pre> <p>Extract subcell structures from a larger structure for crystallization.</p> <p>Parameters:</p> Name Type Description Default <code>fractional_positions</code> <code>ndarray</code> <p>Fractional coordinates of atoms, shape [n_atoms, 3].</p> required <code>species</code> <code>list[str]</code> <p>Chemical element symbols for each atom.</p> required <code>d_frac</code> <code>float</code> <p>Grid spacing in fractional coordinates. Smaller values create more overlap.</p> <code>0.05</code> <code>n_min</code> <code>int</code> <p>Minimum atoms per subcell.</p> <code>1</code> <code>n_max</code> <code>int</code> <p>Maximum atoms per subcell.</p> <code>48</code> <code>restrict_to_compositions</code> <code>Sequence[str]</code> <p>Chemical formulas to filter subcells by (e.g. [\"AB\", \"AB2\"]). Only matching compositions are returned.</p> <code>None</code> <code>max_coeff</code> <code>int</code> <p>Maximum stoichiometric coefficient for auto-generating restrictions. E.g. max_coeff=2 allows AB2 but not AB3.</p> <code>None</code> <code>elements</code> <code>Sequence[str]</code> <p>Elements for generating stoichiometries. Required if max_coeff provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[tuple[ndarray, ndarray, ndarray]]</code> <p>List of (indices, lower_bounds, upper_bounds) where: - indices: Atom indices in subcell - lower_bounds: Lower bounds in fractional coords [3] - upper_bounds: Upper bounds in fractional coords [3]</p> Notes <p>Divides a structure into overlapping subcells that can be relaxed to find stable crystal structures. Uses a grid in fractional coordinates to identify atom groups meeting size and composition criteria.</p>"},{"location":"api/utils/#a2c_ase.utils.default_subcell_filter","title":"default_subcell_filter","text":"<pre><code>default_subcell_filter(subcell: tuple[ndarray, ndarray, ndarray], cubic_only: bool = True, allowed_atom_counts: Optional[list[int]] = None) -&gt; bool\n</code></pre> <p>Filter subcells based on shape and size criteria.</p> <p>Parameters:</p> Name Type Description Default <code>subcell</code> <code>tuple[ndarray, ndarray, ndarray]</code> <p>Tuple containing (atom_indices, lower_bound, upper_bound) arrays that define the subcell</p> required <code>cubic_only</code> <code>bool</code> <p>If True, only accept subcells with equal dimensions in x, y, and z</p> <code>True</code> <code>allowed_atom_counts</code> <code>list[int]</code> <p>List of allowed atom counts. If provided, only accept subcells with specified atom counts</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if subcell meets all criteria, False otherwise</p>"},{"location":"api/utils/#a2c_ase.utils.subcells_to_structures","title":"subcells_to_structures","text":"<pre><code>subcells_to_structures(candidates: list[tuple[ndarray, ndarray, ndarray]], fractional_positions: ndarray, cell: ndarray, species: list[str]) -&gt; list[tuple[np.ndarray, np.ndarray, list[str]]]\n</code></pre> <p>Convert subcell candidates to structure tuples.</p> <p>Parameters:</p> Name Type Description Default <code>candidates</code> <code>list[tuple[ndarray, ndarray, ndarray]]</code> <p>List of (atom_indices, lower_bound, upper_bound) tuples defining subcell regions</p> required <code>fractional_positions</code> <code>ndarray</code> <p>Fractional coordinates of all atoms in parent structure, shape [n_atoms, 3]</p> required <code>cell</code> <code>ndarray</code> <p>3x3 array representing parent unit cell</p> required <code>species</code> <code>list[str]</code> <p>Chemical symbols for all atoms in parent structure</p> required <p>Returns:</p> Type Description <code>list[tuple[ndarray, ndarray, list[str]]]</code> <p>List of (frac_coords, cell, species) tuples for each subcell: - frac_coords: Normalized [0,1] fractional coordinates - cell: Scaled 3x3 subcell - species: Chemical symbols for subcell atoms</p>"},{"location":"api/utils/#a2c_ase.utils.valid_subcell","title":"valid_subcell","text":"<pre><code>valid_subcell(atoms: Atoms, initial_energy: float, final_energy: float, *, e_tol: float = 0.001, fe_lower_limit: float = -5.0, fe_upper_limit: float = 0.0, fusion_distance: float = 1.5, distance_tolerance: float = 0.0001) -&gt; bool\n</code></pre> <p>Validate a relaxed subcell structure.</p> <p>Parameters:</p> Name Type Description Default <code>atoms</code> <code>Atoms</code> <p>ASE Atoms object with atomic positions, species, and cell information.</p> required <code>initial_energy</code> <code>float</code> <p>Total energy before relaxation in eV.</p> required <code>final_energy</code> <code>float</code> <p>Total energy after relaxation in eV.</p> required <code>e_tol</code> <code>float</code> <p>Energy tolerance (eV) for comparing initial and final energies.</p> <code>0.001</code> <code>fe_lower_limit</code> <code>float</code> <p>Lower limit for formation energy (eV/atom). More negative values are unphysical.</p> <code>-5.0</code> <code>fe_upper_limit</code> <code>float</code> <p>Upper limit for formation energy (eV/atom). Higher values indicate poor convergence.</p> <code>0.0</code> <code>fusion_distance</code> <code>float</code> <p>Minimum allowed interatomic distance (\u00c5). Shorter distances indicate atomic fusion.</p> <code>1.5</code> <code>distance_tolerance</code> <code>float</code> <p>Distance tolerance (\u00c5) for considering atoms at same position.</p> <code>0.0001</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if structure passes all validation checks: - Formation energy is physically reasonable - Energy decreased during relaxation - Final energy indicates good convergence - No atomic fusion detected</p>"},{"location":"api/utils/#a2c_ase.utils.min_distance","title":"min_distance","text":"<pre><code>min_distance(structure: Structure, distance_tolerance: float = 0.0001) -&gt; float\n</code></pre> <p>Calculate minimum interatomic distance in a periodic structure.</p> <p>Computes the smallest non-zero distance between any pair of atoms, accounting for periodic boundary conditions. Self-interactions are excluded via a distance tolerance.</p> <p>Parameters:</p> Name Type Description Default <code>structure</code> <code>Structure</code> <p>Pymatgen Structure object containing atomic positions and cell information</p> required <code>distance_tolerance</code> <code>float</code> <p>Distances below this value (in \u00c5) are considered self-interactions and ignored</p> <code>0.0001</code> <p>Returns:</p> Type Description <code>float</code> <p>Minimum distance between any two different atoms in \u00c5</p>"},{"location":"api/utils/#a2c_ase.utils.get_target_temperature","title":"get_target_temperature","text":"<pre><code>get_target_temperature(step: int, equi_steps: int, cool_steps: int, T_high: float, T_low: float) -&gt; float\n</code></pre> <p>Calculate target temperature for a melt-quench-equilibrate simulation step.</p> <p>Parameters:</p> Name Type Description Default <code>step</code> <code>int</code> <p>Current simulation step number (0-indexed)</p> required <code>equi_steps</code> <code>int</code> <p>Number of steps for initial high-temperature equilibration</p> required <code>cool_steps</code> <code>int</code> <p>Number of steps for linear cooling</p> required <code>T_high</code> <code>float</code> <p>Initial high temperature in Kelvin</p> required <code>T_low</code> <code>float</code> <p>Final low temperature in Kelvin</p> required <p>Returns:</p> Type Description <code>float</code> <p>Target temperature in Kelvin for the current step</p> Notes <p>The temperature profile consists of three phases: 1. Initial equilibration at T_high for equi_steps 2. Linear cooling from T_high to T_low over cool_steps 3. Final equilibration at T_low for remaining steps</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; get_target_temperature(10, 100, 200, 2000.0, 300.0)  # During equilibration\n2000.0\n&gt;&gt;&gt; get_target_temperature(200, 100, 200, 2000.0, 300.0)  # During cooling\n1150.0\n&gt;&gt;&gt; get_target_temperature(350, 100, 200, 2000.0, 300.0)  # After cooling\n300.0\n</code></pre>"},{"location":"development/contributing/","title":"Contributing","text":""},{"location":"development/contributing/#setup","title":"Setup","text":"<pre><code># Fork on GitHub, then clone\ngit clone https://github.com/YOUR_USERNAME/a2c_ase.git\ncd a2c_ase\n\n# Install with dev dependencies\npip install -e \".[dev,test]\"\n\n# Set up pre-commit hooks\npre-commit install\n\n# Create branch\ngit checkout -b feature/your-feature-name\n</code></pre>"},{"location":"development/contributing/#development","title":"Development","text":""},{"location":"development/contributing/#code-quality","title":"Code Quality","text":"<pre><code>ruff check        # Lint\nruff format       # Format\nty check          # Type check\npytest            # Test\n</code></pre>"},{"location":"development/contributing/#documentation","title":"Documentation","text":"<pre><code>pip install -e \".[docs]\"\nmkdocs serve      # Preview\n</code></pre>"},{"location":"development/contributing/#code-standards","title":"Code Standards","text":"<ol> <li>PEP 8: Enforced by <code>ruff</code></li> <li>Type hints: Required for all functions</li> <li>Docstrings: NumPy-style format</li> <li>Tests: Required for new features</li> </ol>"},{"location":"development/contributing/#docstring-template","title":"Docstring Template","text":"<pre><code>def function(param: int) -&gt; bool:\n    \"\"\"Brief description.\n\n    Parameters\n    ----------\n    param : int\n        Description\n\n    Returns\n    -------\n    bool\n        Description\n    \"\"\"\n</code></pre>"},{"location":"development/contributing/#testing","title":"Testing","text":""},{"location":"development/contributing/#write-tests","title":"Write Tests","text":"<pre><code>def test_feature():\n    \"\"\"Test description.\"\"\"\n    result = function(input)\n    assert result == expected\n</code></pre>"},{"location":"development/contributing/#run-tests","title":"Run Tests","text":"<pre><code>pytest                    # All tests\npytest -k \"pattern\"       # Match pattern\npytest --cov=a2c_ase      # With coverage\n</code></pre>"},{"location":"development/contributing/#submit-changes","title":"Submit Changes","text":""},{"location":"development/contributing/#commit","title":"Commit","text":"<pre><code>git add .\ngit commit -m \"feat: description\"\n</code></pre> <p>Prefixes: <code>feat:</code>, <code>fix:</code>, <code>docs:</code>, <code>test:</code>, <code>refactor:</code></p>"},{"location":"development/contributing/#push-pr","title":"Push &amp; PR","text":"<pre><code>git push origin feature/your-feature-name\n</code></pre> <p>Create PR on GitHub with clear description.</p>"},{"location":"development/contributing/#pr-checklist","title":"PR Checklist","text":"<ul> <li>[ ] Tests pass</li> <li>[ ] Coverage &gt;= 80%</li> <li>[ ] Type hints</li> <li>[ ] Docstrings</li> </ul>"},{"location":"development/contributing/#reporting-issues","title":"Reporting Issues","text":"<p>Bug reports: Include description, steps to reproduce, environment, minimal example</p> <p>Feature requests: Include description, use case, motivation</p>"},{"location":"development/contributing/#resources","title":"Resources","text":"<ul> <li>Code</li> <li>Tests</li> <li>User Guide</li> </ul>"},{"location":"development/contributing/#license","title":"License","text":"<p>By contributing, you agree that your contributions will be licensed under the MIT License.</p> <p>Thank you!</p>"},{"location":"examples/","title":"Examples","text":"<p>Practical examples demonstrating the a2c workflow.</p>"},{"location":"examples/#1-si64-silicon-crystallization","title":"1. Si64 - Silicon Crystallization","text":"<p>Complete a2c workflow for predicting silicon's crystal structure from an amorphous precursor.</p> <p>Tutorial Docs Source Code</p> <p>Demonstrates: Random structure generation, melt-quench MD, subcell extraction, optimization, and space group analysis.</p>"},{"location":"examples/#2-hull-kob-andersen-binary-system-hull","title":"2. Hull - Kob-Andersen Binary System Hull","text":"<p>Hull exploration with a2c workflow for the classic Kob-Andersen binary Lennard-Jones glass former (Ni80P20).</p> <p>Tutorial Docs Source Code</p> <p>Demonstrates: Binary systems, metal/LJ units, custom cross-interactions, composition analysis.</p>"},{"location":"examples/#3-cell-extraction-sodium-crystallization-analysis","title":"3. Cell Extraction - Sodium Crystallization Analysis","text":"<p>Extract and analyze crystallizable subcells from a pre-generated amorphous sodium structure using ML potential.</p> <p>Tutorial Docs Source Code</p> <p>Demonstrates: Loading existing structures, subcell extraction, ML potential, space group distribution analysis, visualization.</p>"},{"location":"examples/#see-also","title":"See Also","text":"<ul> <li>Understand the workflow: User Guide</li> <li>API documentation: Runner | Utils</li> <li>Quick overview: Quick Start</li> </ul>"},{"location":"examples/Si64/","title":"Silicon","text":"Dependencies /// script requires-python = \"&gt;=3.10\" dependencies = [     \"a2c-ase @ git+https://github.com/abhijeetgangan/a2c_ase.git\",     \"numpy\",     \"pymatgen\",     \"tqdm\",     \"mace-torch\", ] ///  <p>Silicon Crystallization Example</p> <p>This example demonstrates the complete a2c workflow for predicting the crystal structure of silicon from an amorphous precursor using the MACE machine learning potential.</p> In\u00a0[1]: Copied! <pre>import os\nfrom collections import defaultdict\n\nimport numpy as np\nfrom ase.build import bulk\nfrom mace.calculators.foundations_models import mace_mp  # type: ignore\nfrom pymatgen.analysis.structure_analyzer import SpacegroupAnalyzer\nfrom pymatgen.analysis.structure_matcher import StructureMatcher\nfrom pymatgen.core.composition import Composition\nfrom pymatgen.core.structure import Structure\nfrom tqdm import tqdm\n\nfrom a2c_ase.runner import melt_quench_md, relax_unit_cell\nfrom a2c_ase.utils import extract_crystallizable_subcells, random_packed_structure\n</pre> import os from collections import defaultdict  import numpy as np from ase.build import bulk from mace.calculators.foundations_models import mace_mp  # type: ignore from pymatgen.analysis.structure_analyzer import SpacegroupAnalyzer from pymatgen.analysis.structure_matcher import StructureMatcher from pymatgen.core.composition import Composition from pymatgen.core.structure import Structure from tqdm import tqdm  from a2c_ase.runner import melt_quench_md, relax_unit_cell from a2c_ase.utils import extract_crystallizable_subcells, random_packed_structure <pre>/opt/hostedtoolcache/Python/3.10.18/x64/lib/python3.10/site-packages/e3nn/o3/_wigner.py:10: UserWarning: Environment variable TORCH_FORCE_NO_WEIGHTS_ONLY_LOAD detected, since the`weights_only` argument was not explicitly passed to `torch.load`, forcing weights_only=False.\n  _Jd, _W3j_flat, _W3j_indices = torch.load(os.path.join(os.path.dirname(__file__), 'constants.pt'))\n</pre> <pre>cuequivariance or cuequivariance_torch is not available. Cuequivariance acceleration will be disabled.\n</pre> In\u00a0[2]: Copied! <pre>IS_CI = os.getenv(\"CI\") is not None\n\ncomp = Composition(\"Si64\")\ncell = np.array([[11.1, 0.0, 0.0], [0.0, 11.1, 0.0], [0.0, 0.0, 11.1]])\n\n# Optimization parameters\nglobal_seed = 42\nfmax = 0.01  # Force convergence criterion in eV/\u00c5\nmax_iter = 2 if IS_CI else 100\n\n# Molecular dynamics parameters\nmd_log_interval = 50\nmd_equi_steps = 10 if IS_CI else 2500  # High temperature equilibration steps\nmd_cool_steps = 10 if IS_CI else 2500  # Cooling steps\nmd_final_steps = 10 if IS_CI else 2500  # Low temperature equilibration steps\nmd_T_high = 2000.0  # Initial melting temperature (K)\nmd_T_low = 300.0  # Final temperature (K)\nmd_time_step = 2.0  # fs\nmd_friction = 0.01  # Langevin friction\n\nif IS_CI:\n    print(\"Running in CI mode with reduced parameters for fast testing\")\n</pre> IS_CI = os.getenv(\"CI\") is not None  comp = Composition(\"Si64\") cell = np.array([[11.1, 0.0, 0.0], [0.0, 11.1, 0.0], [0.0, 0.0, 11.1]])  # Optimization parameters global_seed = 42 fmax = 0.01  # Force convergence criterion in eV/\u00c5 max_iter = 2 if IS_CI else 100  # Molecular dynamics parameters md_log_interval = 50 md_equi_steps = 10 if IS_CI else 2500  # High temperature equilibration steps md_cool_steps = 10 if IS_CI else 2500  # Cooling steps md_final_steps = 10 if IS_CI else 2500  # Low temperature equilibration steps md_T_high = 2000.0  # Initial melting temperature (K) md_T_low = 300.0  # Final temperature (K) md_time_step = 2.0  # fs md_friction = 0.01  # Langevin friction  if IS_CI:     print(\"Running in CI mode with reduced parameters for fast testing\") <pre>Running in CI mode with reduced parameters for fast testing\n</pre> In\u00a0[3]: Copied! <pre>device = \"cpu\" if IS_CI else \"cuda\"\ncalculator = mace_mp(model=\"small-omat-0\", device=device, dtype=\"float32\")\n</pre> device = \"cpu\" if IS_CI else \"cuda\" calculator = mace_mp(model=\"small-omat-0\", device=device, dtype=\"float32\") <pre>Using model under Academic Software License (ASL) license, see https://github.com/gabor1/ASL \n To use this model you accept the terms of the license.\nDownloading MACE model from 'https://github.com/ACEsuit/mace-mp/releases/download/mace_omat_0/mace-omat-0-small.model'\n</pre> <pre>Cached MACE model to /home/runner/.cache/mace/maceomat0smallmodel\nUsing Materials Project MACE for MACECalculator with /home/runner/.cache/mace/maceomat0smallmodel\nUsing float32 for MACECalculator, which is faster but less accurate. Recommended for MD. Use float64 for geometry optimization.\nUsing head omat_pbe out of ['omat_pbe']\nDefault dtype float32 does not match model dtype float64, converting models to float32.\n</pre> <pre>/opt/hostedtoolcache/Python/3.10.18/x64/lib/python3.10/site-packages/mace/calculators/mace.py:197: UserWarning: Environment variable TORCH_FORCE_NO_WEIGHTS_ONLY_LOAD detected, since the`weights_only` argument was not explicitly passed to `torch.load`, forcing weights_only=False.\n  torch.load(f=model_path, map_location=device)\n</pre> In\u00a0[4]: Copied! <pre>packed_atoms, log_data = random_packed_structure(\n    composition=comp,\n    cell=cell,\n    seed=global_seed,\n    fmax=fmax,\n    max_iter=max_iter,\n    verbose=True,\n    auto_diameter=True,\n    trajectory_file=None,\n)\nprint(f\"Soft sphere packed structure is ready {packed_atoms}\")\n</pre> packed_atoms, log_data = random_packed_structure(     composition=comp,     cell=cell,     seed=global_seed,     fmax=fmax,     max_iter=max_iter,     verbose=True,     auto_diameter=True,     trajectory_file=None, ) print(f\"Soft sphere packed structure is ready {packed_atoms}\") <pre>Using random pack diameter of 2.2\nReduce atom overlap using the soft_sphere potential\nInitial energy: 2.6981\nStep: 0, E: 2.6981, Fmax: 0.4073, Min dist: 0.6425\nStep: 1, E: 2.6761, Fmax: 0.4043, Min dist: 0.6490\nStep: 2, E: 2.6326, Fmax: 0.3984, Min dist: 0.6618\nFinal energy: 2.6326\nSoft sphere packed structure is ready Atoms(symbols='Si64', pbc=True, cell=[11.1, 11.1, 11.1], calculator=SoftSphere(...))\n</pre> In\u00a0[5]: Copied! <pre>amorphous_atoms, md_log = melt_quench_md(\n    atoms=packed_atoms,\n    calculator=calculator,\n    equi_steps=md_equi_steps,\n    cool_steps=md_cool_steps,\n    final_steps=md_final_steps,\n    T_high=md_T_high,\n    T_low=md_T_low,\n    time_step=md_time_step,\n    friction=md_friction,\n    trajectory_file=None,\n    seed=global_seed,\n    verbose=True,\n    log_interval=md_log_interval,\n)\nprint(f\"Final amorphous structure is ready {amorphous_atoms}\")\n</pre> amorphous_atoms, md_log = melt_quench_md(     atoms=packed_atoms,     calculator=calculator,     equi_steps=md_equi_steps,     cool_steps=md_cool_steps,     final_steps=md_final_steps,     T_high=md_T_high,     T_low=md_T_low,     time_step=md_time_step,     friction=md_friction,     trajectory_file=None,     seed=global_seed,     verbose=True,     log_interval=md_log_interval, ) print(f\"Final amorphous structure is ready {amorphous_atoms}\") <pre>Step 0/30: T = 2000.0 K, E_pot = 630.546 eV, E_kin = 16.545 eV\n</pre> <pre>\nMelt-quench simulation completed:\nFinal temperature: 83754.3 K\nFinal energy: -182.198 eV\nFinal amorphous structure is ready Atoms(symbols='Si64', pbc=True, cell=[11.1, 11.1, 11.1], momenta=..., calculator=MACECalculator(...))\n</pre> In\u00a0[6]: Copied! <pre>crystallizable_cells = extract_crystallizable_subcells(\n    atoms=amorphous_atoms,\n    d_frac=0.2,  # Size of subcell as fraction of original cell\n    n_min=2,  # Min atoms per subcell\n    n_max=8,  # Max atoms per subcell\n    cubic_only=True,\n    allowed_atom_counts=[2, 4, 8],\n)\nprint(f\"Generated {len(crystallizable_cells)} candidate structures for crystallization\")\n</pre> crystallizable_cells = extract_crystallizable_subcells(     atoms=amorphous_atoms,     d_frac=0.2,  # Size of subcell as fraction of original cell     n_min=2,  # Min atoms per subcell     n_max=8,  # Max atoms per subcell     cubic_only=True,     allowed_atom_counts=[2, 4, 8], ) print(f\"Generated {len(crystallizable_cells)} candidate structures for crystallization\") <pre>Created 1915 subcells from amorphous structure\nSubcells kept after filtering: 39\nGenerated 39 candidate structures for crystallization\n</pre> In\u00a0[7]: Copied! <pre>relaxed_atoms_list = []\nprint(\"Relaxing candidate structures...\")\nfor atoms in tqdm(crystallizable_cells):\n    # Relax the structure\n    relaxed_atoms, logger = relax_unit_cell(\n        atoms=atoms, calculator=calculator, max_iter=max_iter, fmax=fmax, verbose=False\n    )\n\n    # Get final energy and pressure\n    final_energy = relaxed_atoms.get_potential_energy()\n    final_pressure = -np.trace(relaxed_atoms.get_stress(voigt=False)) / 3.0\n\n    # Store the relaxed structure and its properties\n    relaxed_atoms_list.append((relaxed_atoms, logger, final_energy, final_pressure))\n</pre> relaxed_atoms_list = [] print(\"Relaxing candidate structures...\") for atoms in tqdm(crystallizable_cells):     # Relax the structure     relaxed_atoms, logger = relax_unit_cell(         atoms=atoms, calculator=calculator, max_iter=max_iter, fmax=fmax, verbose=False     )      # Get final energy and pressure     final_energy = relaxed_atoms.get_potential_energy()     final_pressure = -np.trace(relaxed_atoms.get_stress(voigt=False)) / 3.0      # Store the relaxed structure and its properties     relaxed_atoms_list.append((relaxed_atoms, logger, final_energy, final_pressure)) <pre>Relaxing candidate structures...\n</pre> <pre>\r  0%|          | 0/39 [00:00&lt;?, ?it/s]</pre> <pre>\r  3%|\u258e         | 1/39 [00:00&lt;00:17,  2.16it/s]</pre> <pre>\r  5%|\u258c         | 2/39 [00:00&lt;00:18,  1.99it/s]</pre> <pre>\r  8%|\u258a         | 3/39 [00:01&lt;00:17,  2.06it/s]</pre> <pre>\r 10%|\u2588         | 4/39 [00:01&lt;00:16,  2.07it/s]</pre> <pre>\r 13%|\u2588\u258e        | 5/39 [00:02&lt;00:15,  2.19it/s]</pre> <pre>\r 15%|\u2588\u258c        | 6/39 [00:02&lt;00:14,  2.24it/s]</pre> <pre>\r 18%|\u2588\u258a        | 7/39 [00:03&lt;00:16,  1.97it/s]</pre> <pre>\r 21%|\u2588\u2588        | 8/39 [00:04&lt;00:18,  1.64it/s]</pre> <pre>\r 23%|\u2588\u2588\u258e       | 9/39 [00:04&lt;00:16,  1.86it/s]</pre> <pre>\r 26%|\u2588\u2588\u258c       | 10/39 [00:05&lt;00:17,  1.66it/s]</pre> <pre>\r 28%|\u2588\u2588\u258a       | 11/39 [00:05&lt;00:15,  1.77it/s]</pre> <pre>\r 31%|\u2588\u2588\u2588       | 12/39 [00:06&lt;00:13,  2.01it/s]</pre> <pre>\r 33%|\u2588\u2588\u2588\u258e      | 13/39 [00:06&lt;00:12,  2.12it/s]</pre> <pre>\r 36%|\u2588\u2588\u2588\u258c      | 14/39 [00:07&lt;00:13,  1.91it/s]</pre> <pre>\r 38%|\u2588\u2588\u2588\u258a      | 15/39 [00:07&lt;00:11,  2.00it/s]</pre> <pre>\r 41%|\u2588\u2588\u2588\u2588      | 16/39 [00:08&lt;00:11,  1.96it/s]</pre> <pre>\r 44%|\u2588\u2588\u2588\u2588\u258e     | 17/39 [00:08&lt;00:11,  1.98it/s]</pre> <pre>\r 46%|\u2588\u2588\u2588\u2588\u258c     | 18/39 [00:09&lt;00:11,  1.90it/s]</pre> <pre>\r 49%|\u2588\u2588\u2588\u2588\u258a     | 19/39 [00:09&lt;00:09,  2.02it/s]</pre> <pre>\r 51%|\u2588\u2588\u2588\u2588\u2588\u258f    | 20/39 [00:10&lt;00:08,  2.30it/s]</pre> <pre>\r 54%|\u2588\u2588\u2588\u2588\u2588\u258d    | 21/39 [00:10&lt;00:08,  2.10it/s]</pre> <pre>\r 56%|\u2588\u2588\u2588\u2588\u2588\u258b    | 22/39 [00:11&lt;00:08,  2.02it/s]</pre> <pre>\r 59%|\u2588\u2588\u2588\u2588\u2588\u2589    | 23/39 [00:11&lt;00:07,  2.12it/s]</pre> <pre>\r 62%|\u2588\u2588\u2588\u2588\u2588\u2588\u258f   | 24/39 [00:12&lt;00:07,  1.89it/s]</pre> <pre>\r 64%|\u2588\u2588\u2588\u2588\u2588\u2588\u258d   | 25/39 [00:12&lt;00:06,  2.05it/s]</pre> <pre>\r 67%|\u2588\u2588\u2588\u2588\u2588\u2588\u258b   | 26/39 [00:12&lt;00:05,  2.21it/s]</pre> <pre>\r 69%|\u2588\u2588\u2588\u2588\u2588\u2588\u2589   | 27/39 [00:13&lt;00:05,  2.27it/s]</pre> <pre>\r 72%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f  | 28/39 [00:13&lt;00:05,  2.03it/s]</pre> <pre>\r 74%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d  | 29/39 [00:14&lt;00:05,  1.88it/s]</pre> <pre>\r 77%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b  | 30/39 [00:15&lt;00:05,  1.73it/s]</pre> <pre>\r 79%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589  | 31/39 [00:15&lt;00:04,  1.87it/s]</pre> <pre>\r 82%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f | 32/39 [00:16&lt;00:03,  2.09it/s]</pre> <pre>\r 85%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d | 33/39 [00:16&lt;00:02,  2.29it/s]</pre> <pre>\r 87%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b | 34/39 [00:16&lt;00:02,  2.23it/s]</pre> <pre>\r 90%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589 | 35/39 [00:17&lt;00:01,  2.47it/s]</pre> <pre>\r 92%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f| 36/39 [00:17&lt;00:01,  2.63it/s]</pre> <pre>\r 95%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d| 37/39 [00:17&lt;00:00,  2.48it/s]</pre> <pre>\r 97%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b| 38/39 [00:18&lt;00:00,  2.48it/s]</pre> <pre>\r100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 39/39 [00:18&lt;00:00,  2.24it/s]</pre> <pre>\r100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 39/39 [00:18&lt;00:00,  2.06it/s]</pre> <pre>\n</pre> In\u00a0[8]: Copied! <pre>lowest_e_candidate = min(relaxed_atoms_list, key=lambda x: x[-2] / len(x[0]))\nlowest_e_atoms, lowest_e_logger, lowest_e_energy, lowest_e_pressure = lowest_e_candidate\n\n# Convert to pymatgen structure for space group analysis\npymatgen_struct = Structure(\n    lattice=lowest_e_atoms.get_cell(),\n    species=lowest_e_atoms.get_chemical_symbols(),\n    coords=lowest_e_atoms.get_positions(),\n    coords_are_cartesian=True,\n)\n\n# Analyze space group\nspg = SpacegroupAnalyzer(pymatgen_struct)\nprint(\"Space group of predicted crystallization product:\", spg.get_space_group_symbol())\nprint(\n    f\"Final energy: {lowest_e_energy:.4f} eV, \"\n    f\"Energy per atom: {lowest_e_energy / len(lowest_e_atoms):.4f} eV/atom\"\n)\nprint(f\"Final pressure: {lowest_e_pressure:.6f} eV/\u00c5\u00b3\")\n\n# Count frequency of space groups across all candidates\nspg_counter = defaultdict(lambda: 0)\n\nfor s in relaxed_atoms_list:\n    pymatgen_struct = Structure(\n        lattice=s[0].get_cell(),\n        species=s[0].get_chemical_symbols(),\n        coords=s[0].get_positions(),\n        coords_are_cartesian=True,\n    )\n    try:\n        sp = SpacegroupAnalyzer(pymatgen_struct).get_space_group_symbol()\n        spg_counter[sp] += 1\n    except TypeError:\n        continue\n\n\nprint(\"All space groups encountered:\", dict(spg_counter))\n\n# Compare to reference diamond structure\nsi_diamond = bulk(\"Si\", \"diamond\", a=5.43)\npymatgen_ref_struct = Structure(\n    lattice=si_diamond.get_cell(),\n    species=si_diamond.get_chemical_symbols(),\n    coords=si_diamond.get_positions(),\n    coords_are_cartesian=True,\n)\nprint(\n    \"Prediction matches diamond-cubic Si?\",\n    StructureMatcher().fit(pymatgen_struct, pymatgen_ref_struct),\n)\n\n# Save the lowest energy structure\nlowest_e_atoms.write(\"final_crystal_structure.cif\")\nprint(\"Lowest energy structure saved to final_crystal_structure.cif\")\n</pre> lowest_e_candidate = min(relaxed_atoms_list, key=lambda x: x[-2] / len(x[0])) lowest_e_atoms, lowest_e_logger, lowest_e_energy, lowest_e_pressure = lowest_e_candidate  # Convert to pymatgen structure for space group analysis pymatgen_struct = Structure(     lattice=lowest_e_atoms.get_cell(),     species=lowest_e_atoms.get_chemical_symbols(),     coords=lowest_e_atoms.get_positions(),     coords_are_cartesian=True, )  # Analyze space group spg = SpacegroupAnalyzer(pymatgen_struct) print(\"Space group of predicted crystallization product:\", spg.get_space_group_symbol()) print(     f\"Final energy: {lowest_e_energy:.4f} eV, \"     f\"Energy per atom: {lowest_e_energy / len(lowest_e_atoms):.4f} eV/atom\" ) print(f\"Final pressure: {lowest_e_pressure:.6f} eV/\u00c5\u00b3\")  # Count frequency of space groups across all candidates spg_counter = defaultdict(lambda: 0)  for s in relaxed_atoms_list:     pymatgen_struct = Structure(         lattice=s[0].get_cell(),         species=s[0].get_chemical_symbols(),         coords=s[0].get_positions(),         coords_are_cartesian=True,     )     try:         sp = SpacegroupAnalyzer(pymatgen_struct).get_space_group_symbol()         spg_counter[sp] += 1     except TypeError:         continue   print(\"All space groups encountered:\", dict(spg_counter))  # Compare to reference diamond structure si_diamond = bulk(\"Si\", \"diamond\", a=5.43) pymatgen_ref_struct = Structure(     lattice=si_diamond.get_cell(),     species=si_diamond.get_chemical_symbols(),     coords=si_diamond.get_positions(),     coords_are_cartesian=True, ) print(     \"Prediction matches diamond-cubic Si?\",     StructureMatcher().fit(pymatgen_struct, pymatgen_ref_struct), )  # Save the lowest energy structure lowest_e_atoms.write(\"final_crystal_structure.cif\") print(\"Lowest energy structure saved to final_crystal_structure.cif\") <pre>Space group of predicted crystallization product: P1\nFinal energy: -18.5615 eV, Energy per atom: -4.6404 eV/atom\nFinal pressure: -0.018813 eV/\u00c5\u00b3\nAll space groups encountered: {'P1': 25, 'P-1': 13, 'P2_1/m': 1}\nPrediction matches diamond-cubic Si? False\nLowest energy structure saved to final_crystal_structure.cif\n</pre>"},{"location":"examples/Si64/#setup-and-imports","title":"Setup and Imports\u00b6","text":"<p>We'll use MACE for accurate energy and force calculations.</p>"},{"location":"examples/Si64/#configuration","title":"Configuration\u00b6","text":"<p>Define the system (Si64) and simulation parameters. In CI mode, we use reduced parameters for faster testing.</p>"},{"location":"examples/Si64/#step-1-initialize-mace-calculator","title":"Step 1: Initialize MACE Calculator\u00b6","text":"<p>MACE is a state-of-the-art machine learning potential trained on diverse materials data.</p>"},{"location":"examples/Si64/#step-2-generate-random-packed-structure","title":"Step 2: Generate Random Packed Structure\u00b6","text":"<p>Create an initial random configuration with no severe atomic overlaps.</p>"},{"location":"examples/Si64/#step-3-melt-quench-md-simulation","title":"Step 3: Melt-Quench MD Simulation\u00b6","text":"<p>Heat to 2000K, quench to 300K to create an amorphous structure.</p>"},{"location":"examples/Si64/#step-4-extract-crystallizable-subcells","title":"Step 4: Extract Crystallizable Subcells\u00b6","text":"<p>Divide the amorphous structure into overlapping subcells.</p>"},{"location":"examples/Si64/#step-5-optimize-subcells","title":"Step 5: Optimize Subcells\u00b6","text":"<p>Relax each subcell to find stable crystalline structures.</p>"},{"location":"examples/Si64/#step-6-analyze-results","title":"Step 6: Analyze Results\u00b6","text":"<p>Find the lowest energy structure and determine its space group.</p>"},{"location":"examples/cell_extraction/","title":"Cell Extraction","text":"Dependencies /// script requires-python = \"&gt;=3.10\" dependencies = [     \"a2c-ase @ git+https://github.com/abhijeetgangan/a2c_ase.git\",     \"numpy\",     \"pymatgen\",     \"tqdm\",     \"mace-torch\",     \"matplotlib\", ] ///  <p>Sodium Crystallization from Amorphous Phase - Cell Extraction Example</p> <p>This example demonstrates how to extract crystallizable subcells from an amorphous sodium structure, relax them using the MACE machine learning potential, and analyze the resulting space group distribution. This is a simplified workflow that focuses on the cell extraction and analysis steps without running the full melt-quench MD simulation.</p> In\u00a0[1]: Copied! <pre>import os\nfrom collections import Counter\nfrom pathlib import Path\n\nimport matplotlib\nimport matplotlib.pyplot as plt\nfrom ase.io import read\nfrom mace.calculators.foundations_models import mace_mp  # type: ignore\nfrom pymatgen.io.ase import AseAtomsAdaptor\nfrom pymatgen.symmetry.analyzer import SpacegroupAnalyzer\nfrom tqdm import tqdm\n\nfrom a2c_ase.runner import relax_unit_cell\nfrom a2c_ase.utils import extract_crystallizable_subcells\n\n# Set matplotlib backend for CI\nif os.getenv(\"CI\") is not None:\n    matplotlib.use(\"Agg\")\n</pre> import os from collections import Counter from pathlib import Path  import matplotlib import matplotlib.pyplot as plt from ase.io import read from mace.calculators.foundations_models import mace_mp  # type: ignore from pymatgen.io.ase import AseAtomsAdaptor from pymatgen.symmetry.analyzer import SpacegroupAnalyzer from tqdm import tqdm  from a2c_ase.runner import relax_unit_cell from a2c_ase.utils import extract_crystallizable_subcells  # Set matplotlib backend for CI if os.getenv(\"CI\") is not None:     matplotlib.use(\"Agg\") <pre>/opt/hostedtoolcache/Python/3.10.18/x64/lib/python3.10/site-packages/e3nn/o3/_wigner.py:10: UserWarning: Environment variable TORCH_FORCE_NO_WEIGHTS_ONLY_LOAD detected, since the`weights_only` argument was not explicitly passed to `torch.load`, forcing weights_only=False.\n  _Jd, _W3j_flat, _W3j_indices = torch.load(os.path.join(os.path.dirname(__file__), 'constants.pt'))\n</pre> <pre>cuequivariance or cuequivariance_torch is not available. Cuequivariance acceleration will be disabled.\n</pre> In\u00a0[2]: Copied! <pre>IS_CI = os.getenv(\"CI\") is not None\n\n# Get the path to the data file relative to this script\ntry:\n    script_dir = Path(__file__).parent\nexcept NameError:\n    script_dir = Path.cwd()\n\n# Search for data file in multiple locations\nfor parent in [script_dir.parent, script_dir, script_dir.parent.parent]:\n    data_file = parent / \"data\" / \"Na_2000.xyz\"\n    if data_file.exists():\n        break\nelse:\n    msg = f\"Could not find data/Na_2000.xyz. Run from project root. CWD: {Path.cwd()}\"\n    raise FileNotFoundError(msg) from None\n\n# Relaxation parameters\nmax_iter = 20 if IS_CI else 200  # Maximum optimization steps\nfmax = 0.01 if IS_CI else 0.05  # Force convergence criterion in eV/\u00c5\n\nif IS_CI:\n    print(\"Running in CI mode with reduced parameters for fast testing\")\n</pre> IS_CI = os.getenv(\"CI\") is not None  # Get the path to the data file relative to this script try:     script_dir = Path(__file__).parent except NameError:     script_dir = Path.cwd()  # Search for data file in multiple locations for parent in [script_dir.parent, script_dir, script_dir.parent.parent]:     data_file = parent / \"data\" / \"Na_2000.xyz\"     if data_file.exists():         break else:     msg = f\"Could not find data/Na_2000.xyz. Run from project root. CWD: {Path.cwd()}\"     raise FileNotFoundError(msg) from None  # Relaxation parameters max_iter = 20 if IS_CI else 200  # Maximum optimization steps fmax = 0.01 if IS_CI else 0.05  # Force convergence criterion in eV/\u00c5  if IS_CI:     print(\"Running in CI mode with reduced parameters for fast testing\") <pre>Running in CI mode with reduced parameters for fast testing\n</pre> In\u00a0[3]: Copied! <pre>amorphous_atoms = read(data_file, index=\"0\")\nprint(f\"Loaded structure with {len(amorphous_atoms)} atoms\")\nprint(f\"Cell dimensions: {amorphous_atoms.cell.lengths()}\")  # type: ignore\n</pre> amorphous_atoms = read(data_file, index=\"0\") print(f\"Loaded structure with {len(amorphous_atoms)} atoms\") print(f\"Cell dimensions: {amorphous_atoms.cell.lengths()}\")  # type: ignore <pre>Loaded structure with 2000 atoms\nCell dimensions: [42.3 42.3 42.3]\n</pre> In\u00a0[4]: Copied! <pre>crystallizable_cells = extract_crystallizable_subcells(\n    atoms=amorphous_atoms,  # type: ignore\n    d_frac=0.15,  # Grid spacing as fraction of cell dimensions\n    n_min=2,  # Minimum grid divisions per dimension\n    n_max=12,  # Maximum grid divisions per dimension\n    cubic_only=False,  # Allow non-cubic structures\n    allowed_atom_counts=None,  # No restriction on number of atoms per cell\n)\n\nprint(f\"Found {len(crystallizable_cells)} crystallizable cells\")\n</pre>  crystallizable_cells = extract_crystallizable_subcells(     atoms=amorphous_atoms,  # type: ignore     d_frac=0.15,  # Grid spacing as fraction of cell dimensions     n_min=2,  # Minimum grid divisions per dimension     n_max=12,  # Maximum grid divisions per dimension     cubic_only=False,  # Allow non-cubic structures     allowed_atom_counts=None,  # No restriction on number of atoms per cell )  print(f\"Found {len(crystallizable_cells)} crystallizable cells\") <pre>Created 214 subcells from amorphous structure\nSubcells kept after filtering: 214\nFound 214 crystallizable cells\n</pre> In\u00a0[5]: Copied! <pre>device = \"cpu\" if IS_CI else \"cuda\"\ncalculator = mace_mp(model=\"small-omat-0\", device=device, dtype=\"float32\")\nprint(f\"MACE calculator initialized on {device}\")\n</pre> device = \"cpu\" if IS_CI else \"cuda\" calculator = mace_mp(model=\"small-omat-0\", device=device, dtype=\"float32\") print(f\"MACE calculator initialized on {device}\") <pre>Using model under Academic Software License (ASL) license, see https://github.com/gabor1/ASL \n To use this model you accept the terms of the license.\nUsing Materials Project MACE for MACECalculator with /home/runner/.cache/mace/maceomat0smallmodel\nUsing float32 for MACECalculator, which is faster but less accurate. Recommended for MD. Use float64 for geometry optimization.\nUsing head omat_pbe out of ['omat_pbe']\nDefault dtype float32 does not match model dtype float64, converting models to float32.\nMACE calculator initialized on cpu\n</pre> <pre>/opt/hostedtoolcache/Python/3.10.18/x64/lib/python3.10/site-packages/mace/calculators/mace.py:197: UserWarning: Environment variable TORCH_FORCE_NO_WEIGHTS_ONLY_LOAD detected, since the`weights_only` argument was not explicitly passed to `torch.load`, forcing weights_only=False.\n  torch.load(f=model_path, map_location=device)\n</pre> In\u00a0[6]: Copied! <pre>space_groups = []\nrelaxed_cells = []\n\nprint(\"Relaxing structures...\")\nfor atoms in tqdm(crystallizable_cells[:20] if IS_CI else crystallizable_cells):\n    relaxed_cell, log_dict = relax_unit_cell(\n        atoms=atoms,\n        calculator=calculator,\n        max_iter=max_iter,\n        fmax=fmax,\n        verbose=False,\n    )\n\n    # Convert to pymatgen and get space group\n    adaptor = AseAtomsAdaptor()\n    structure = adaptor.get_structure(relaxed_cell)\n    sga = SpacegroupAnalyzer(structure, symprec=0.1)\n    space_group = sga.get_space_group_symbol()\n\n    space_groups.append(space_group)\n    relaxed_cells.append(relaxed_cell)\n\nprint(f\"Successfully relaxed {len(relaxed_cells)} structures\")\n</pre> space_groups = [] relaxed_cells = []  print(\"Relaxing structures...\") for atoms in tqdm(crystallizable_cells[:20] if IS_CI else crystallizable_cells):     relaxed_cell, log_dict = relax_unit_cell(         atoms=atoms,         calculator=calculator,         max_iter=max_iter,         fmax=fmax,         verbose=False,     )      # Convert to pymatgen and get space group     adaptor = AseAtomsAdaptor()     structure = adaptor.get_structure(relaxed_cell)     sga = SpacegroupAnalyzer(structure, symprec=0.1)     space_group = sga.get_space_group_symbol()      space_groups.append(space_group)     relaxed_cells.append(relaxed_cell)  print(f\"Successfully relaxed {len(relaxed_cells)} structures\") <pre>Relaxing structures...\n</pre> <pre>\r  0%|          | 0/20 [00:00&lt;?, ?it/s]</pre> <pre>\r  5%|\u258c         | 1/20 [00:03&lt;01:13,  3.86s/it]</pre> <pre>\r 10%|\u2588         | 2/20 [00:07&lt;01:08,  3.82s/it]</pre> <pre>\r 15%|\u2588\u258c        | 3/20 [00:11&lt;01:04,  3.80s/it]</pre> <pre>\r 20%|\u2588\u2588        | 4/20 [00:15&lt;01:00,  3.78s/it]</pre> <pre>\r 25%|\u2588\u2588\u258c       | 5/20 [00:18&lt;00:54,  3.62s/it]</pre> <pre>\r 30%|\u2588\u2588\u2588       | 6/20 [00:22&lt;00:52,  3.75s/it]</pre> <pre>\r 35%|\u2588\u2588\u2588\u258c      | 7/20 [00:26&lt;00:48,  3.69s/it]</pre> <pre>\r 40%|\u2588\u2588\u2588\u2588      | 8/20 [00:29&lt;00:45,  3.76s/it]</pre> <pre>\r 45%|\u2588\u2588\u2588\u2588\u258c     | 9/20 [00:34&lt;00:42,  3.89s/it]</pre> <pre>\r 50%|\u2588\u2588\u2588\u2588\u2588     | 10/20 [00:38&lt;00:39,  3.97s/it]</pre> <pre>\r 55%|\u2588\u2588\u2588\u2588\u2588\u258c    | 11/20 [00:42&lt;00:35,  3.95s/it]</pre> <pre>\r 60%|\u2588\u2588\u2588\u2588\u2588\u2588    | 12/20 [00:46&lt;00:31,  3.91s/it]</pre> <pre>\r 65%|\u2588\u2588\u2588\u2588\u2588\u2588\u258c   | 13/20 [00:50&lt;00:28,  4.04s/it]</pre> <pre>\r 70%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588   | 14/20 [00:54&lt;00:23,  3.95s/it]</pre> <pre>\r 75%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c  | 15/20 [00:57&lt;00:19,  3.80s/it]</pre> <pre>\r 80%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588  | 16/20 [01:00&lt;00:14,  3.64s/it]</pre> <pre>\r 85%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c | 17/20 [01:04&lt;00:11,  3.70s/it]</pre> <pre>\r 90%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 | 18/20 [01:08&lt;00:07,  3.61s/it]</pre> <pre>\r 95%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c| 19/20 [01:11&lt;00:03,  3.62s/it]</pre> <pre>\r100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 20/20 [01:15&lt;00:00,  3.72s/it]</pre> <pre>\r100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 20/20 [01:15&lt;00:00,  3.78s/it]</pre> <pre>Successfully relaxed 20 structures\n</pre> <pre>\n</pre> In\u00a0[7]: Copied! <pre>space_group_counts = Counter(space_groups)\nsorted_groups = sorted(space_group_counts.items(), key=lambda x: x[1], reverse=True)\n\n# Create visualization\nfig, ax = plt.subplots(figsize=(9, 6))\nlabels = [sg[0] for sg in sorted_groups]\ncounts = [sg[1] for sg in sorted_groups]\n\nax.bar(range(len(labels)), counts)\nax.set_xticks(range(len(labels)))\nax.set_xticklabels(labels, rotation=45, ha=\"right\")\nax.set_xlabel(\"Space Group\")\nax.set_ylabel(\"Count\")\nax.set_title(\"Space Group Distribution of Relaxed Structures\")\nax.grid(axis=\"y\", alpha=0.3)\n\nplt.tight_layout()\n\n# Save plot (skip display in CI)\nif not IS_CI:\n    output_file = script_dir / \"space_group_distribution.png\"\n    plt.savefig(output_file, dpi=300, bbox_inches=\"tight\")\n    print(f\"\\nPlot saved to {output_file}\")\n    plt.show()\nelse:\n    plt.close()  # Clean up in CI\n</pre> space_group_counts = Counter(space_groups) sorted_groups = sorted(space_group_counts.items(), key=lambda x: x[1], reverse=True)  # Create visualization fig, ax = plt.subplots(figsize=(9, 6)) labels = [sg[0] for sg in sorted_groups] counts = [sg[1] for sg in sorted_groups]  ax.bar(range(len(labels)), counts) ax.set_xticks(range(len(labels))) ax.set_xticklabels(labels, rotation=45, ha=\"right\") ax.set_xlabel(\"Space Group\") ax.set_ylabel(\"Count\") ax.set_title(\"Space Group Distribution of Relaxed Structures\") ax.grid(axis=\"y\", alpha=0.3)  plt.tight_layout()  # Save plot (skip display in CI) if not IS_CI:     output_file = script_dir / \"space_group_distribution.png\"     plt.savefig(output_file, dpi=300, bbox_inches=\"tight\")     print(f\"\\nPlot saved to {output_file}\")     plt.show() else:     plt.close()  # Clean up in CI In\u00a0[8]: Copied! <pre>print(\"\\nSpace Group Statistics:\")\nfor sg, count in sorted_groups:\n    percentage = count / len(space_groups) * 100\n    print(f\"{sg}: {count} structures ({percentage:&gt;5.1f}%)\")\nprint(f\"Total: {len(space_groups)} unique structures analyzed\")\n</pre> print(\"\\nSpace Group Statistics:\") for sg, count in sorted_groups:     percentage = count / len(space_groups) * 100     print(f\"{sg}: {count} structures ({percentage:&gt;5.1f}%)\") print(f\"Total: {len(space_groups)} unique structures analyzed\") <pre>\nSpace Group Statistics:\nP1: 20 structures (100.0%)\nTotal: 20 unique structures analyzed\n</pre>"},{"location":"examples/cell_extraction/#setup-and-imports","title":"Setup and Imports\u00b6","text":"<p>We'll use MACE for accurate energy and force calculations, pymatgen for space group analysis, and matplotlib for visualization.</p>"},{"location":"examples/cell_extraction/#configuration","title":"Configuration\u00b6","text":"<p>Define paths and simulation parameters. In CI mode, we use reduced parameters for faster testing.</p>"},{"location":"examples/cell_extraction/#step-1-load-amorphous-structure","title":"Step 1: Load Amorphous Structure\u00b6","text":"<p>Load the pre-generated amorphous sodium structure from the data directory. This structure was obtained from a melt-quench simulation.</p>"},{"location":"examples/cell_extraction/#step-2-extract-crystallizable-subcells","title":"Step 2: Extract Crystallizable Subcells\u00b6","text":"<p>Search for periodic subcells within the amorphous structure that could represent crystalline unit cells. The algorithm uses a grid-based search to identify regions with translational symmetry.</p>"},{"location":"examples/cell_extraction/#step-3-initialize-mace-calculator","title":"Step 3: Initialize MACE Calculator\u00b6","text":""},{"location":"examples/cell_extraction/#step-4-relax-candidate-structures","title":"Step 4: Relax Candidate Structures\u00b6","text":"<p>For each extracted subcell, we perform a full structure relaxation (both atomic positions and cell parameters) using the FIRE optimizer. This identifies the energetically favorable crystalline structures.</p>"},{"location":"examples/cell_extraction/#step-5-analyze-space-group-distribution","title":"Step 5: Analyze Space Group Distribution\u00b6","text":"<p>Analyze the symmetry of relaxed structures to understand what crystal structures are accessible from the amorphous precursor. For sodium, we expect to see body-centered cubic (bcc, space group Im-3m) as the most stable phase at ambient conditions.</p>"},{"location":"examples/cell_extraction/#results-summary","title":"Results Summary\u00b6","text":"<p>Print detailed statistics about the space group distribution. This helps identify the most frequently occurring crystal structures.</p>"},{"location":"examples/hull/","title":"Hull","text":"Dependencies /// script requires-python = \"&gt;=3.10\" dependencies = [     \"a2c-ase @ git+https://github.com/abhijeetgangan/a2c_ase.git\",     \"numpy\",     \"pymatgen\",     \"tqdm\",     \"plotly\",     \"kaleido\", ] ///  <p>Kob-Andersen Binary System - a2c Workflow</p> <p>Hull exploration with a2c workflow for the classic Kob-Andersen binary Lennard-Jones glass former. Uses reduced units (LJ natural units: sigma, epsilon).</p> In\u00a0[1]: Copied! <pre>import os\nfrom collections import Counter\n\nimport numpy as np\nfrom ase import Atoms\nfrom ase.build import bulk\nfrom pymatgen.analysis.phase_diagram import PDEntry, PDPlotter, PhaseDiagram\nfrom pymatgen.core.composition import Composition\nfrom tqdm import tqdm\n\nfrom a2c_ase.potentials.mlj import MultiLennardJones\nfrom a2c_ase.runner import melt_quench_md, relax_unit_cell\nfrom a2c_ase.utils import extract_crystallizable_subcells, random_packed_structure\n\nIS_CI = os.getenv(\"CI\") is not None\n</pre> import os from collections import Counter  import numpy as np from ase import Atoms from ase.build import bulk from pymatgen.analysis.phase_diagram import PDEntry, PDPlotter, PhaseDiagram from pymatgen.core.composition import Composition from tqdm import tqdm  from a2c_ase.potentials.mlj import MultiLennardJones from a2c_ase.runner import melt_quench_md, relax_unit_cell from a2c_ase.utils import extract_crystallizable_subcells, random_packed_structure  IS_CI = os.getenv(\"CI\") is not None In\u00a0[2]: Copied! <pre># System configuration (80:20 A:B composition)\ncomp = Composition(\"Ni80P20\")\n\n# Cell in LJ units (sigma as length unit)\ncell_size = 4.4\ncell = np.array([[cell_size, 0.0, 0.0], [0.0, cell_size, 0.0], [0.0, 0.0, cell_size]])\n\n# Kob-Andersen calculator (reduced/LJ units)\ncalculator = MultiLennardJones(\n    sigma={\"Ni\": 1.0, \"P\": 0.88},  # LJ sigma in natural units\n    epsilon={\"Ni\": 1.0, \"P\": 0.5},  # LJ epsilon in natural units\n    cross_interactions={(\"Ni\", \"P\"): {\"sigma\": 0.8, \"epsilon\": 1.5}},\n    rc=2.5,  # Cutoff in units of sigma\n    smooth=True,\n)\n</pre> # System configuration (80:20 A:B composition) comp = Composition(\"Ni80P20\")  # Cell in LJ units (sigma as length unit) cell_size = 4.4 cell = np.array([[cell_size, 0.0, 0.0], [0.0, cell_size, 0.0], [0.0, 0.0, cell_size]])  # Kob-Andersen calculator (reduced/LJ units) calculator = MultiLennardJones(     sigma={\"Ni\": 1.0, \"P\": 0.88},  # LJ sigma in natural units     epsilon={\"Ni\": 1.0, \"P\": 0.5},  # LJ epsilon in natural units     cross_interactions={(\"Ni\", \"P\"): {\"sigma\": 0.8, \"epsilon\": 1.5}},     rc=2.5,  # Cutoff in units of sigma     smooth=True, ) In\u00a0[3]: Copied! <pre>global_seed = 42\nfmax = 0.01  # Force convergence in reduced units\n\n# Reduce parameters for CI testing\nmax_iter = 20 if IS_CI else 200\n\n# MD parameters (LJ units)\nmd_log_interval = 50\nmd_equi_steps = 100 if IS_CI else 2500\nmd_cool_steps = 100 if IS_CI else 2500\nmd_final_steps = 100 if IS_CI else 2500\nmd_T_high = 4.0  # High T* (reduced units, above glass transition ~0.8)\nmd_T_low = 0.4  # Low T* (reduced units, below glass transition)\nmd_time_step = 0.005  # Timestep in reduced units\nmd_friction = 1 / (100 * md_time_step)  # Friction coefficient\n\nif IS_CI:\n    print(\"Running in CI mode with reduced parameters\")\n</pre> global_seed = 42 fmax = 0.01  # Force convergence in reduced units  # Reduce parameters for CI testing max_iter = 20 if IS_CI else 200  # MD parameters (LJ units) md_log_interval = 50 md_equi_steps = 100 if IS_CI else 2500 md_cool_steps = 100 if IS_CI else 2500 md_final_steps = 100 if IS_CI else 2500 md_T_high = 4.0  # High T* (reduced units, above glass transition ~0.8) md_T_low = 0.4  # Low T* (reduced units, below glass transition) md_time_step = 0.005  # Timestep in reduced units md_friction = 1 / (100 * md_time_step)  # Friction coefficient  if IS_CI:     print(\"Running in CI mode with reduced parameters\") <pre>Running in CI mode with reduced parameters\n</pre> In\u00a0[4]: Copied! <pre>packed_atoms, log_data = random_packed_structure(\n    composition=comp,\n    cell=cell,\n    seed=global_seed,\n    diameter=2.5,\n    max_iter=max_iter,\n    fmax=fmax,\n    verbose=True,\n    auto_diameter=False,\n)\nprint(f\"Generated packed structure: {packed_atoms}\")\nprint(f\"Number of Ni (A) atoms: {sum(1 for s in packed_atoms.symbols if s == 'Ni')}\")\nprint(f\"Number of P (B) atoms: {sum(1 for s in packed_atoms.symbols if s == 'P')}\")\n</pre> packed_atoms, log_data = random_packed_structure(     composition=comp,     cell=cell,     seed=global_seed,     diameter=2.5,     max_iter=max_iter,     fmax=fmax,     verbose=True,     auto_diameter=False, ) print(f\"Generated packed structure: {packed_atoms}\") print(f\"Number of Ni (A) atoms: {sum(1 for s in packed_atoms.symbols if s == 'Ni')}\") print(f\"Number of P (B) atoms: {sum(1 for s in packed_atoms.symbols if s == 'P')}\") <pre>Reduce atom overlap using the soft_sphere potential\nInitial energy: 186.9468\nStep: 0, E: 186.9468, Fmax: 1.7763, Min dist: 0.1037\nStep: 1, E: 186.1019, Fmax: 1.7140, Min dist: 0.1120\nStep: 2, E: 184.5282, Fmax: 1.5892, Min dist: 0.1259\n</pre> <pre>Step: 3, E: 182.9326, Fmax: 1.4488, Min dist: 0.1413\nStep: 4, E: 181.4750, Fmax: 1.3043, Min dist: 0.1570\nStep: 5, E: 180.1550, Fmax: 1.1980, Min dist: 0.1732\nStep: 6, E: 178.9719, Fmax: 1.0905, Min dist: 0.1900\n</pre> <pre>Step: 7, E: 177.9247, Fmax: 0.9773, Min dist: 0.2075\nStep: 8, E: 177.0115, Fmax: 0.8635, Min dist: 0.2259\nStep: 9, E: 176.2302, Fmax: 0.7401, Min dist: 0.2453\nStep: 10, E: 175.5772, Fmax: 0.6216, Min dist: 0.2661\nStep: 11, E: 175.0457, Fmax: 0.5197, Min dist: 0.2883\n</pre> <pre>Step: 12, E: 174.6261, Fmax: 0.4208, Min dist: 0.3123\nStep: 13, E: 174.3075, Fmax: 0.3560, Min dist: 0.3384\nStep: 14, E: 174.0753, Fmax: 0.3206, Min dist: 0.3669\nStep: 15, E: 173.9128, Fmax: 0.3017, Min dist: 0.3980\nStep: 16, E: 173.8007, Fmax: 0.3088, Min dist: 0.4317\nStep: 17, E: 173.7181, Fmax: 0.3481, Min dist: 0.4679\n</pre> <pre>Step: 18, E: 173.6440, Fmax: 0.3657, Min dist: 0.5062\nStep: 19, E: 173.5592, Fmax: 0.3609, Min dist: 0.5459\nStep: 20, E: 173.4504, Fmax: 0.3319, Min dist: 0.5582\nFinal energy: 173.4504\nGenerated packed structure: Atoms(symbols='Ni80P20', pbc=True, cell=[4.4, 4.4, 4.4], calculator=SoftSphere(...))\nNumber of Ni (A) atoms: 80\nNumber of P (B) atoms: 20\n</pre> In\u00a0[5]: Copied! <pre># Relax the packed structure so that the initial structure doesn't have\n# large forces for melt-quench MD.\npacked_atoms, logger = relax_unit_cell(\n    atoms=packed_atoms, calculator=calculator, max_iter=max_iter, fmax=fmax, verbose=True\n)\n</pre> # Relax the packed structure so that the initial structure doesn't have # large forces for melt-quench MD. packed_atoms, logger = relax_unit_cell(     atoms=packed_atoms, calculator=calculator, max_iter=max_iter, fmax=fmax, verbose=True ) <pre>Initial energy: 24103.049587 eV\nInitial volume: 85.184 \u00c5\u00b3\nInitial pressure: 1208.881066 eV/\u00c5\u00b3\nStep 0: E = 24103.049587 eV, Fmax = 92475.904440 eV/\u00c5, P = 1208.881066 eV/\u00c5\u00b3, V = 85.184 \u00c5\u00b3\n</pre> <pre>Step 1: E = 9201.490457 eV, Fmax = 9653.251133 eV/\u00c5, P = 500.139940 eV/\u00c5\u00b3, V = 85.186 \u00c5\u00b3\n</pre> <pre>Step 2: E = 6933.804645 eV, Fmax = 13343.286963 eV/\u00c5, P = 390.315734 eV/\u00c5\u00b3, V = 85.190 \u00c5\u00b3\n</pre> <pre>Step 3: E = 5566.112354 eV, Fmax = 8726.639546 eV/\u00c5, P = 323.785760 eV/\u00c5\u00b3, V = 85.195 \u00c5\u00b3\n</pre> <pre>Step 4: E = 4520.803711 eV, Fmax = 5452.583236 eV/\u00c5, P = 272.783127 eV/\u00c5\u00b3, V = 85.200 \u00c5\u00b3\n</pre> <pre>Step 5: E = 3890.780941 eV, Fmax = 5077.364589 eV/\u00c5, P = 241.627518 eV/\u00c5\u00b3, V = 85.207 \u00c5\u00b3\nStep 6: E = 3381.857741 eV, Fmax = 4181.581220 eV/\u00c5, P = 216.357357 eV/\u00c5\u00b3, V = 85.215 \u00c5\u00b3\n</pre> <pre>Step 7: E = 2907.676084 eV, Fmax = 4455.688123 eV/\u00c5, P = 192.861648 eV/\u00c5\u00b3, V = 85.224 \u00c5\u00b3\n</pre> <pre>Step 8: E = 2517.345085 eV, Fmax = 4636.406730 eV/\u00c5, P = 173.471604 eV/\u00c5\u00b3, V = 85.234 \u00c5\u00b3\n</pre> <pre>Step 9: E = 2204.754508 eV, Fmax = 4495.762339 eV/\u00c5, P = 157.920712 eV/\u00c5\u00b3, V = 85.245 \u00c5\u00b3\n</pre> <pre>Step 10: E = 1969.702478 eV, Fmax = 2682.887341 eV/\u00c5, P = 146.213460 eV/\u00c5\u00b3, V = 85.258 \u00c5\u00b3\n</pre> <pre>Step 11: E = 1842.936639 eV, Fmax = 2818.194326 eV/\u00c5, P = 139.733149 eV/\u00c5\u00b3, V = 85.271 \u00c5\u00b3\n</pre> <pre>Step 12: E = 1145.771025 eV, Fmax = 730.623441 eV/\u00c5, P = 104.316168 eV/\u00c5\u00b3, V = 85.281 \u00c5\u00b3\n</pre> <pre>Step 13: E = 833.955456 eV, Fmax = 1207.098799 eV/\u00c5, P = 87.827478 eV/\u00c5\u00b3, V = 85.294 \u00c5\u00b3\nStep 14: E = 595.840582 eV, Fmax = 516.955791 eV/\u00c5, P = 75.143666 eV/\u00c5\u00b3, V = 85.310 \u00c5\u00b3\n</pre> <pre>Step 15: E = 416.414893 eV, Fmax = 384.055368 eV/\u00c5, P = 65.443928 eV/\u00c5\u00b3, V = 85.329 \u00c5\u00b3\nStep 16: E = 256.310322 eV, Fmax = 322.465777 eV/\u00c5, P = 56.774559 eV/\u00c5\u00b3, V = 85.349 \u00c5\u00b3\n</pre> <pre>Step 17: E = 123.041348 eV, Fmax = 232.079330 eV/\u00c5, P = 49.503373 eV/\u00c5\u00b3, V = 85.371 \u00c5\u00b3\nStep 18: E = 25.253097 eV, Fmax = 309.653331 eV/\u00c5, P = 44.049215 eV/\u00c5\u00b3, V = 85.395 \u00c5\u00b3\n</pre> <pre>Step 19: E = -52.095182 eV, Fmax = 452.306409 eV/\u00c5, P = 39.653908 eV/\u00c5\u00b3, V = 85.421 \u00c5\u00b3\nStep 20: E = -127.192693 eV, Fmax = 321.594908 eV/\u00c5, P = 35.421277 eV/\u00c5\u00b3, V = 85.448 \u00c5\u00b3\n\nOptimization completed:\nFinal energy: -127.192693 eV\nFinal volume: 85.448 \u00c5\u00b3\nFinal pressure: 35.421277 eV/\u00c5\u00b3\nSteps taken: 20\n</pre> In\u00a0[6]: Copied! <pre>amorphous_atoms, md_log = melt_quench_md(\n    atoms=packed_atoms,\n    calculator=calculator,\n    equi_steps=md_equi_steps,\n    cool_steps=md_cool_steps,\n    final_steps=md_final_steps,\n    T_high=md_T_high,\n    T_low=md_T_low,\n    time_step=md_time_step,\n    friction=md_friction,\n    seed=global_seed,\n    verbose=True,\n    log_interval=md_log_interval,\n)\nprint(f\"Amorphous structure ready: {amorphous_atoms}\")\n</pre> amorphous_atoms, md_log = melt_quench_md(     atoms=packed_atoms,     calculator=calculator,     equi_steps=md_equi_steps,     cool_steps=md_cool_steps,     final_steps=md_final_steps,     T_high=md_T_high,     T_low=md_T_low,     time_step=md_time_step,     friction=md_friction,     seed=global_seed,     verbose=True,     log_interval=md_log_interval, ) print(f\"Amorphous structure ready: {amorphous_atoms}\") <pre>Step 0/300: T = 4.0 K, E_pot = -127.193 eV, E_kin = 0.052 eV\n</pre> <pre>Step 50/300: T = 387.7 K, E_pot = -132.315 eV, E_kin = 5.012 eV\n</pre> <pre>Step 100/300: T = 1372.4 K, E_pot = -146.128 eV, E_kin = 17.739 eV\n</pre> <pre>Step 150/300: T = 2665.8 K, E_pot = -165.371 eV, E_kin = 34.458 eV\n</pre> <pre>Step 200/300: T = 4000.5 K, E_pot = -186.808 eV, E_kin = 51.710 eV\n</pre> <pre>Step 250/300: T = 5196.7 K, E_pot = -208.140 eV, E_kin = 67.173 eV\n</pre> <pre>\nMelt-quench simulation completed:\nFinal temperature: 6187.7 K\nFinal energy: -228.141 eV\nAmorphous structure ready: Atoms(symbols='Ni80P20', pbc=True, cell=[[4.404302085217416, 0.0004704354711196714, -0.00011483479060379136], [0.0004703656985870155, 4.405225004480768, 0.0005501805715166627], [-0.00011486374903597653, 0.0005501986925379699, 4.404104872625505]], momenta=..., calculator=MultiLennardJones(...))\n</pre> In\u00a0[7]: Copied! <pre>crystallizable_cells = extract_crystallizable_subcells(\n    atoms=amorphous_atoms,\n    d_frac=0.25,  # Grid spacing (larger for binary system)\n    n_min=2,\n    n_max=8,  # Allow larger subcells for binary compounds\n    cubic_only=False,  # Allow non-cubic structures\n    allowed_atom_counts=None,  # Don't restrict by count\n    restrict_to_compositions=[\n        \"Ni\",\n        \"NiP\",\n        \"Ni2P\",\n        \"Ni4P\",\n        \"NiP2\",\n        \"NiP4\",\n        \"P\",\n    ],  # Only consider these compositions\n    max_coeff=None,\n    elements=None,\n)\nprint(f\"Extracted {len(crystallizable_cells)} candidate subcells\")\n</pre> crystallizable_cells = extract_crystallizable_subcells(     atoms=amorphous_atoms,     d_frac=0.25,  # Grid spacing (larger for binary system)     n_min=2,     n_max=8,  # Allow larger subcells for binary compounds     cubic_only=False,  # Allow non-cubic structures     allowed_atom_counts=None,  # Don't restrict by count     restrict_to_compositions=[         \"Ni\",         \"NiP\",         \"Ni2P\",         \"Ni4P\",         \"NiP2\",         \"NiP4\",         \"P\",     ],  # Only consider these compositions     max_coeff=None,     elements=None, ) print(f\"Extracted {len(crystallizable_cells)} candidate subcells\") <pre>Created 261 subcells from amorphous structure\nSubcells kept after filtering: 261\nExtracted 261 candidate subcells\n</pre> In\u00a0[8]: Copied! <pre>relaxed_structures = []\nprint(\"Optimizing candidate structures...\")\n\nfor atoms in tqdm(crystallizable_cells[:20] if IS_CI else crystallizable_cells):\n    try:\n        relaxed, logger = relax_unit_cell(\n            atoms=atoms, calculator=calculator, max_iter=max_iter, fmax=fmax, verbose=False\n        )\n\n        final_energy = relaxed.get_potential_energy()\n        energy_per_atom = final_energy / len(relaxed)\n\n        relaxed_structures.append((relaxed, energy_per_atom, final_energy))\n    except Exception as e:\n        print(f\"Optimization failed: {e}\")\n        continue\n\nprint(f\"Successfully optimized {len(relaxed_structures)} structures\")\n</pre> relaxed_structures = [] print(\"Optimizing candidate structures...\")  for atoms in tqdm(crystallizable_cells[:20] if IS_CI else crystallizable_cells):     try:         relaxed, logger = relax_unit_cell(             atoms=atoms, calculator=calculator, max_iter=max_iter, fmax=fmax, verbose=False         )          final_energy = relaxed.get_potential_energy()         energy_per_atom = final_energy / len(relaxed)          relaxed_structures.append((relaxed, energy_per_atom, final_energy))     except Exception as e:         print(f\"Optimization failed: {e}\")         continue  print(f\"Successfully optimized {len(relaxed_structures)} structures\") <pre>Optimizing candidate structures...\n</pre> <pre>\r  0%|          | 0/20 [00:00&lt;?, ?it/s]</pre> <pre>\r  5%|\u258c         | 1/20 [00:01&lt;00:23,  1.22s/it]</pre> <pre>\r 10%|\u2588         | 2/20 [00:02&lt;00:24,  1.36s/it]</pre> <pre>\r 15%|\u2588\u258c        | 3/20 [00:04&lt;00:23,  1.35s/it]</pre> <pre>\r 20%|\u2588\u2588        | 4/20 [00:05&lt;00:20,  1.31s/it]</pre> <pre>\r 25%|\u2588\u2588\u258c       | 5/20 [00:06&lt;00:19,  1.31s/it]</pre> <pre>\r 30%|\u2588\u2588\u2588       | 6/20 [00:07&lt;00:16,  1.16s/it]</pre> <pre>\r 35%|\u2588\u2588\u2588\u258c      | 7/20 [00:08&lt;00:16,  1.24s/it]</pre> <pre>\r 40%|\u2588\u2588\u2588\u2588      | 8/20 [00:10&lt;00:15,  1.28s/it]</pre> <pre>\r 45%|\u2588\u2588\u2588\u2588\u258c     | 9/20 [00:11&lt;00:13,  1.22s/it]</pre> <pre>\r 50%|\u2588\u2588\u2588\u2588\u2588     | 10/20 [00:12&lt;00:13,  1.31s/it]</pre> <pre>\r 55%|\u2588\u2588\u2588\u2588\u2588\u258c    | 11/20 [00:14&lt;00:11,  1.29s/it]</pre> <pre>\r 60%|\u2588\u2588\u2588\u2588\u2588\u2588    | 12/20 [00:15&lt;00:10,  1.33s/it]</pre> <pre>\r 65%|\u2588\u2588\u2588\u2588\u2588\u2588\u258c   | 13/20 [00:17&lt;00:10,  1.44s/it]</pre> <pre>\r 70%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588   | 14/20 [00:18&lt;00:08,  1.34s/it]</pre> <pre>\r 75%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c  | 15/20 [00:20&lt;00:07,  1.48s/it]</pre> <pre>\r 80%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588  | 16/20 [00:21&lt;00:05,  1.49s/it]</pre> <pre>\r 85%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c | 17/20 [00:23&lt;00:04,  1.51s/it]</pre> <pre>\r 90%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 | 18/20 [00:24&lt;00:03,  1.55s/it]</pre> <pre>\r 95%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c| 19/20 [00:25&lt;00:01,  1.35s/it]</pre> <pre>\r100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 20/20 [00:27&lt;00:00,  1.51s/it]</pre> <pre>\r100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 20/20 [00:27&lt;00:00,  1.38s/it]</pre> <pre>Successfully optimized 20 structures\n</pre> <pre>\n</pre> In\u00a0[9]: Copied! <pre># Build convex hull with proper composition handling\nentries = []\nfor atoms, _, total_e in relaxed_structures:\n    # Get composition from symbol counts (more explicit and correct)\n    symbol_counts = Counter(atoms.get_chemical_symbols())\n    comp_obj = Composition(symbol_counts)  # e.g., {'Ni': 2, 'P': 1} -&gt; Ni2P\n    entries.append(PDEntry(comp_obj, total_e))\n\n# Compute reference energies using proper crystal structures\nprint(\"\\nComputing reference energies...\")\n\n# Pure Ni: FCC structure\nni_fcc = bulk(\"Ni\", \"fcc\", a=1.5)\nni_relaxed, _ = relax_unit_cell(ni_fcc, calculator, max_iter=max_iter, fmax=fmax, verbose=False)\ne_ni_total = ni_relaxed.get_potential_energy()\nprint(f\"Ni (FCC): {e_ni_total / len(ni_relaxed):.4f} \u03b5/atom\")\n\n# Pure P: FCC structure\np_fcc = bulk(\"P\", \"fcc\", a=1.3)\np_relaxed, _ = relax_unit_cell(p_fcc, calculator, max_iter=max_iter, fmax=fmax, verbose=False)\ne_p_total = p_relaxed.get_potential_energy()\nprint(f\"P (FCC): {e_p_total / len(p_relaxed):.4f} \u03b5/atom\")\n\n# Ni4P structure\nalat = 4.0\nni4p = Atoms(\n    \"Ni4P\",\n    positions=[\n        [0.0, 0.0, 0.0],\n        [0.0, alat / 2, alat / 2],\n        [alat / 2, 0.0, alat / 2],\n        [alat / 2, alat / 2, 0.0],\n        [alat / 2, alat / 2, alat / 2],\n    ],\n    cell=[alat, alat, alat],\n    pbc=True,\n)\nni4p_relaxed, _ = relax_unit_cell(ni4p, calculator, max_iter=max_iter, fmax=fmax, verbose=False)\ne_ni4p_total = ni4p_relaxed.get_potential_energy()\nprint(f\"Ni4P (Rocksalt): {e_ni4p_total / len(ni4p_relaxed):.4f} \u03b5/atom\")\n\n# Add references with TOTAL energies\nentries.extend(\n    [\n        PDEntry(Composition(\"Ni\"), e_ni_total),\n        PDEntry(Composition(\"P\"), e_p_total),\n        PDEntry(Composition(\"Ni4P\"), e_ni4p_total),\n    ]\n)\npd = PhaseDiagram(entries)\n\nfor i, (atoms, e_per_atom, total_e) in enumerate(relaxed_structures):\n    symbol_counts = Counter(atoms.get_chemical_symbols())\n    comp_obj = Composition(symbol_counts)\n    entry = PDEntry(comp_obj, total_e)\n    e_above_hull = pd.get_e_above_hull(entry)\n\n    print(\n        f\"{i + 1:2d}. {comp_obj.reduced_formula:10s} | \"\n        f\"E/atom: {e_per_atom:8.4f} \u03b5 | \"\n        f\"E_hull: {e_above_hull:8.4f} \u03b5/atom\"\n    )\n\nprint(f\"\\nTotal structures analyzed: {len(relaxed_structures)}\")\nprint(f\"Total entries in phase diagram: {len(entries)}\")\n\n# Plot and save phase diagram\nplotter = PDPlotter(pd, show_unstable=1000.0, backend=\"plotly\")  # Very large value to show all\nplotter.get_plot()\nplotter.show()\n</pre> # Build convex hull with proper composition handling entries = [] for atoms, _, total_e in relaxed_structures:     # Get composition from symbol counts (more explicit and correct)     symbol_counts = Counter(atoms.get_chemical_symbols())     comp_obj = Composition(symbol_counts)  # e.g., {'Ni': 2, 'P': 1} -&gt; Ni2P     entries.append(PDEntry(comp_obj, total_e))  # Compute reference energies using proper crystal structures print(\"\\nComputing reference energies...\")  # Pure Ni: FCC structure ni_fcc = bulk(\"Ni\", \"fcc\", a=1.5) ni_relaxed, _ = relax_unit_cell(ni_fcc, calculator, max_iter=max_iter, fmax=fmax, verbose=False) e_ni_total = ni_relaxed.get_potential_energy() print(f\"Ni (FCC): {e_ni_total / len(ni_relaxed):.4f} \u03b5/atom\")  # Pure P: FCC structure p_fcc = bulk(\"P\", \"fcc\", a=1.3) p_relaxed, _ = relax_unit_cell(p_fcc, calculator, max_iter=max_iter, fmax=fmax, verbose=False) e_p_total = p_relaxed.get_potential_energy() print(f\"P (FCC): {e_p_total / len(p_relaxed):.4f} \u03b5/atom\")  # Ni4P structure alat = 4.0 ni4p = Atoms(     \"Ni4P\",     positions=[         [0.0, 0.0, 0.0],         [0.0, alat / 2, alat / 2],         [alat / 2, 0.0, alat / 2],         [alat / 2, alat / 2, 0.0],         [alat / 2, alat / 2, alat / 2],     ],     cell=[alat, alat, alat],     pbc=True, ) ni4p_relaxed, _ = relax_unit_cell(ni4p, calculator, max_iter=max_iter, fmax=fmax, verbose=False) e_ni4p_total = ni4p_relaxed.get_potential_energy() print(f\"Ni4P (Rocksalt): {e_ni4p_total / len(ni4p_relaxed):.4f} \u03b5/atom\")  # Add references with TOTAL energies entries.extend(     [         PDEntry(Composition(\"Ni\"), e_ni_total),         PDEntry(Composition(\"P\"), e_p_total),         PDEntry(Composition(\"Ni4P\"), e_ni4p_total),     ] ) pd = PhaseDiagram(entries)  for i, (atoms, e_per_atom, total_e) in enumerate(relaxed_structures):     symbol_counts = Counter(atoms.get_chemical_symbols())     comp_obj = Composition(symbol_counts)     entry = PDEntry(comp_obj, total_e)     e_above_hull = pd.get_e_above_hull(entry)      print(         f\"{i + 1:2d}. {comp_obj.reduced_formula:10s} | \"         f\"E/atom: {e_per_atom:8.4f} \u03b5 | \"         f\"E_hull: {e_above_hull:8.4f} \u03b5/atom\"     )  print(f\"\\nTotal structures analyzed: {len(relaxed_structures)}\") print(f\"Total entries in phase diagram: {len(entries)}\")  # Plot and save phase diagram plotter = PDPlotter(pd, show_unstable=1000.0, backend=\"plotly\")  # Very large value to show all plotter.get_plot() plotter.show() <pre>\nComputing reference energies...\n</pre> <pre>Ni (FCC): -7.5898 \u03b5/atom\n</pre> <pre>P (FCC): -3.9678 \u03b5/atom\n</pre> <pre>Ni4P (Rocksalt): -0.0487 \u03b5/atom\n 1. Ni         | E/atom:  -6.2349 \u03b5 | E_hull:   1.3549 \u03b5/atom\n 2. Ni         | E/atom:  -6.0107 \u03b5 | E_hull:   1.5791 \u03b5/atom\n 3. Ni         | E/atom:  -7.5310 \u03b5 | E_hull:   0.0588 \u03b5/atom\n 4. Ni         | E/atom:  -7.5515 \u03b5 | E_hull:   0.0383 \u03b5/atom\n 5. Ni         | E/atom:  -5.2685 \u03b5 | E_hull:   2.3213 \u03b5/atom\n 6. Ni2P       | E/atom:  -4.9320 \u03b5 | E_hull:   1.4505 \u03b5/atom\n 7. Ni4P       | E/atom:  -6.0789 \u03b5 | E_hull:   0.7865 \u03b5/atom\n 8. Ni         | E/atom:  -6.2571 \u03b5 | E_hull:   1.3327 \u03b5/atom\n 9. Ni         | E/atom:  -3.5867 \u03b5 | E_hull:   4.0031 \u03b5/atom\n10. Ni         | E/atom:  -5.8764 \u03b5 | E_hull:   1.7134 \u03b5/atom\n11. Ni         | E/atom:  10.7466 \u03b5 | E_hull:  18.3364 \u03b5/atom\n12. Ni         | E/atom:  -2.9921 \u03b5 | E_hull:   4.5977 \u03b5/atom\n13. Ni         | E/atom:  -6.7571 \u03b5 | E_hull:   0.8327 \u03b5/atom\n14. Ni         | E/atom:  -6.4479 \u03b5 | E_hull:   1.1419 \u03b5/atom\n15. Ni         | E/atom:  -6.8673 \u03b5 | E_hull:   0.7225 \u03b5/atom\n16. Ni         | E/atom:  -5.4651 \u03b5 | E_hull:   2.1247 \u03b5/atom\n17. Ni         | E/atom:   3.4467 \u03b5 | E_hull:  11.0365 \u03b5/atom\n18. Ni         | E/atom:  -4.6192 \u03b5 | E_hull:   2.9706 \u03b5/atom\n19. Ni         | E/atom:  -5.7809 \u03b5 | E_hull:   1.8089 \u03b5/atom\n20. Ni         | E/atom:   2.2377 \u03b5 | E_hull:   9.8275 \u03b5/atom\n\nTotal structures analyzed: 20\nTotal entries in phase diagram: 23\n</pre>"},{"location":"examples/hull/#setup-and-imports","title":"Setup and Imports\u00b6","text":"<p>The Kob-Andersen model is a classic binary Lennard-Jones system that forms metallic glasses. We use reduced units: distances in sigma, energies in epsilon. We will demonstrate how we can explore the hull for a selected compositions.</p>"},{"location":"examples/hull/#kob-andersen-parameters","title":"Kob-Andersen Parameters\u00b6","text":"<p>Classic binary LJ glass former with reduced units (dimensionless):</p> <ul> <li>A particles (Ni): 80%, \u03c3=1.0, \u03b5=1.0 (reference)</li> <li>B particles (P): 20%, \u03c3=0.88, \u03b5=0.5</li> <li>Cross: \u03c3_AB=0.8, \u03b5_AB=1.5</li> <li>Glass transition: T_g \u2248 0.435 (in reduced units)</li> </ul>"},{"location":"examples/hull/#simulation-parameters","title":"Simulation Parameters\u00b6","text":"<p>All parameters in reduced LJ units (dimensionless):</p> <ul> <li>Energy: \u03b5 (epsilon) = 1.0</li> <li>Distance: \u03c3 (sigma) = 1.0</li> <li>Temperature: T* = kT/\u03b5</li> <li>Time: \u03c4 = \u221a(m\u03c3\u00b2/\u03b5) (dimensionless)</li> </ul>"},{"location":"examples/hull/#step-1-generate-random-packed-structure","title":"Step 1: Generate Random Packed Structure\u00b6","text":"<p>Create initial random configuration with A and B particles.</p>"},{"location":"examples/hull/#step-2-melt-quench-md-simulation","title":"Step 2: Melt-Quench MD Simulation\u00b6","text":"<p>Heat to T=4.0, quench to T=0.4 (near T_g\u22480.435).</p>"},{"location":"examples/hull/#step-3-extract-crystallizable-subcells","title":"Step 3: Extract Crystallizable Subcells\u00b6","text":"<p>Divide the glass into overlapping subcells to search for local crystalline order. In this example, we will only consider the following compositions: Ni, NiP, Ni2P, Ni4P, NiP2, NiP4, P.</p>"},{"location":"examples/hull/#step-4-optimize-subcells","title":"Step 4: Optimize Subcells\u00b6","text":"<p>Relax each subcell to find stable crystalline phases.</p>"},{"location":"examples/hull/#step-5-construct-convex-hull","title":"Step 5: Construct Convex Hull\u00b6","text":"<p>Determine thermodynamic stability using pymatgen's phase diagram.</p>"},{"location":"getting-started/installation/","title":"Installation","text":""},{"location":"getting-started/installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.10 or higher</li> <li>pip or uv package manager</li> </ul>"},{"location":"getting-started/installation/#from-pypi-recommended","title":"From PyPI (Recommended)","text":"<p>Install the latest stable release from PyPI:</p> uvpip <pre><code>uv pip install a2c-ase\n</code></pre> <pre><code>pip install a2c-ase\n</code></pre>"},{"location":"getting-started/installation/#from-source","title":"From Source","text":"<p>For development or to get the latest unreleased features:</p> uvpip <pre><code>git clone https://github.com/abhijeetgangan/a2c_ase.git\ncd a2c_ase\nuv pip install .\n</code></pre> <pre><code>git clone https://github.com/abhijeetgangan/a2c_ase.git\ncd a2c_ase\npip install .\n</code></pre>"},{"location":"getting-started/installation/#with-development-dependencies","title":"With Development Dependencies","text":"<p>If you plan to contribute or run tests:</p> pipuv <pre><code>pip install -e \".[dev,test]\"\n</code></pre> <pre><code>uv pip install -e \".[dev,test]\"\n</code></pre>"},{"location":"getting-started/installation/#calculator-dependencies","title":"Calculator Dependencies","text":"<p><code>a2c_ase</code> works with any ASE-compatible calculator. You'll need to install the specific calculator package you want to use.</p>"},{"location":"getting-started/installation/#other-calculators","title":"Other Calculators","text":"<p>For the MACE machine learning potential:</p> pipuv <pre><code>pip install mace-torch\n</code></pre> <pre><code>uv pip install mace-torch\n</code></pre>"},{"location":"getting-started/installation/#development-setup","title":"Development Setup","text":"<p>For contributors, set up the development environment:</p> <ol> <li> <p>Clone the repository: <pre><code>git clone https://github.com/abhijeetgangan/a2c_ase.git\ncd a2c_ase\n</code></pre></p> </li> <li> <p>Install with development dependencies:</p> </li> </ol> pipuv <pre><code>pip install -e \".[dev,test]\"\n</code></pre> <pre><code>uv pip install -e \".[dev,test]\"\n</code></pre> <ol> <li> <p>Set up pre-commit hooks: <pre><code>pre-commit install\n</code></pre></p> </li> <li> <p>Run tests to verify everything works: <pre><code>pytest\n</code></pre></p> </li> </ol>"},{"location":"getting-started/installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/installation/#calculator-not-found","title":"Calculator Not Found","text":"<p>Make sure you've installed the calculator package you're trying to use. For example, for MACE:</p> pipuv <pre><code>pip install mace-torch\n</code></pre> <pre><code>uv pip install mace-torch\n</code></pre>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<p>Now that you have <code>a2c_ase</code> installed, proceed to the Quick Start Guide to run your first workflow!</p>"},{"location":"getting-started/quickstart/","title":"Quick Start","text":"<p>Get started with <code>a2c_ase</code> in minutes.</p>"},{"location":"getting-started/quickstart/#prerequisites","title":"Prerequisites","text":"<ul> <li><code>a2c_ase</code> installed (Installation Guide)</li> <li>A calculator installed (MACE)</li> </ul> pipuv <pre><code>pip install mace-torch\n</code></pre> <pre><code>uv pip install mace-torch\n</code></pre>"},{"location":"getting-started/quickstart/#five-step-workflow","title":"Five-Step Workflow","text":""},{"location":"getting-started/quickstart/#1-generate-random-structure","title":"1. Generate Random Structure","text":"<pre><code>from a2c_ase.utils import random_packed_structure\nfrom pymatgen.core.composition import Composition\nimport numpy as np\n\ncomp = Composition(\"Si64\")\ncell = np.array([[11.1, 0.0, 0.0], [0.0, 11.1, 0.0], [0.0, 0.0, 11.1]])\n\natoms, log = random_packed_structure(comp, cell, auto_diameter=True)\n</code></pre>"},{"location":"getting-started/quickstart/#2-run-melt-quench-md","title":"2. Run Melt-Quench MD","text":"<pre><code>from a2c_ase.runner import melt_quench_md\n\namorphous, md_log = melt_quench_md(\n    atoms, calculator,\n    T_high=2000.0, T_low=300.0,\n    equi_steps=2500, cool_steps=2500, final_steps=2500\n)\n</code></pre>"},{"location":"getting-started/quickstart/#3-extract-subcells","title":"3. Extract Subcells","text":"<pre><code>from a2c_ase.utils import extract_crystallizable_subcells\n\nsubcells = extract_crystallizable_subcells(\n    amorphous, d_frac=0.2, n_min=2, n_max=8, cubic_only=True\n)\n</code></pre>"},{"location":"getting-started/quickstart/#4-optimize-structures","title":"4. Optimize Structures","text":"<pre><code>from a2c_ase.runner import relax_unit_cell\n\nfor subcell in subcells:\n    relaxed, logger = relax_unit_cell(subcell, calculator, fmax=0.01)\n    # Analyze relaxed structure\n</code></pre>"},{"location":"getting-started/quickstart/#5-analyze-results","title":"5. Analyze Results","text":"<pre><code>from pymatgen.analysis.structure_analyzer import SpacegroupAnalyzer\n\n# Find lowest energy and determine space group\n# Compare to reference structures\n</code></pre>"},{"location":"getting-started/quickstart/#complete-example","title":"Complete Example","text":"<p>See the full working example: example/Si64.py</p>"},{"location":"getting-started/quickstart/#next-steps","title":"Next Steps","text":"<ul> <li>Understand the workflow: User Guide</li> <li>API documentation: Runner | Utils</li> <li>Full example: Si64.py Example</li> </ul>"},{"location":"getting-started/quickstart/#tips","title":"Tips","text":"<p>Memory</p> <p>Large systems with many subcells need significant memory. Use larger <code>d_frac</code> or smaller <code>n_max</code> to reduce subcell count.</p>"},{"location":"potentials/multi-lj/","title":"Multi-Lennard-Jones Potential","text":"<p>The Multi-Lennard-Jones calculator implements the classic Lennard-Jones potential with support for multiple chemical species and custom mixing rules.</p>"},{"location":"potentials/multi-lj/#theory","title":"Theory","text":""},{"location":"potentials/multi-lj/#potential-form","title":"Potential Form","text":"<p>The Lennard-Jones potential between atoms \\(i\\) and \\(j\\) is:</p> \\[ u_{ij}(r) = 4\\epsilon_{ij} \\left[\\left(\\frac{\\sigma_{ij}}{r}\\right)^{12} - \\left(\\frac{\\sigma_{ij}}{r}\\right)^6\\right] \\] <p>Where:</p> <ul> <li>\\(\\sigma_{ij}\\): Distance at which potential is zero</li> <li>\\(\\epsilon_{ij}\\): Depth of potential well</li> <li>\\(r\\): Interatomic distance</li> </ul>"},{"location":"potentials/multi-lj/#force","title":"Force","text":"\\[ \\mathbf{F}_{ij} = 24\\epsilon_{ij} \\left[2\\left(\\frac{\\sigma_{ij}}{r}\\right)^{12} - \\left(\\frac{\\sigma_{ij}}{r}\\right)^6\\right] \\frac{\\mathbf{r}_{ij}}{r^2} \\]"},{"location":"potentials/multi-lj/#usage","title":"Usage","text":""},{"location":"potentials/multi-lj/#single-species","title":"Single Species","text":"<pre><code>from a2c_ase.potentials.mlj import MultiLennardJones\nfrom ase import Atoms\n\n# Create atoms\natoms = Atoms('Ar10', positions=..., cell=..., pbc=True)\n\n# Create calculator\ncalculator = MultiLennardJones(\n    epsilon=1.0,    # eV\n    sigma=3.4,      # \u00c5\n    rc=10.0        # Cutoff (\u00c5)\n)\n\natoms.calc = calculator\nenergy = atoms.get_potential_energy()\n</code></pre>"},{"location":"potentials/multi-lj/#multiple-species","title":"Multiple Species","text":"<pre><code># Dictionary specification\ncalculator = MultiLennardJones(\n    epsilon={\"Fe\": 0.5, \"B\": 0.3},\n    sigma={\"Fe\": 2.5, \"B\": 1.8},\n    rc=10.0\n)\n</code></pre>"},{"location":"potentials/multi-lj/#parameters","title":"Parameters","text":"Parameter Type Default Description <code>epsilon</code> float/dict 1.0 Well depth (eV) <code>sigma</code> float/dict 1.0 Zero-crossing distance (\u00c5) <code>rc</code> float None Cutoff distance (auto: 3\u03c3) <code>ro</code> float None Smooth cutoff onset (auto: 0.66rc) <code>smooth</code> bool False Use smooth cutoff <code>mixing_rule</code> str \"lorentz_berthelot\" Mixing rule <code>cross_interactions</code> dict None Explicit cross-interactions"},{"location":"potentials/multi-lj/#mixing-rules","title":"Mixing Rules","text":""},{"location":"potentials/multi-lj/#lorentz-berthelot-default","title":"Lorentz-Berthelot (Default)","text":"\\[ \\sigma_{ij} = \\frac{\\sigma_i + \\sigma_j}{2} \\] \\[ \\epsilon_{ij} = \\sqrt{\\epsilon_i \\epsilon_j} \\] <pre><code>calculator = MultiLennardJones(\n    epsilon={\"A\": 1.0, \"B\": 1.5},\n    sigma={\"A\": 1.0, \"B\": 0.8},\n    mixing_rule=\"lorentz_berthelot\"\n)\n</code></pre>"},{"location":"potentials/multi-lj/#geometric","title":"Geometric","text":"\\[ \\sigma_{ij} = \\sqrt{\\sigma_i \\sigma_j} \\] \\[ \\epsilon_{ij} = \\sqrt{\\epsilon_i \\epsilon_j} \\] <pre><code>calculator = MultiLennardJones(\n    epsilon={\"A\": 1.0, \"B\": 1.5},\n    sigma={\"A\": 1.0, \"B\": 0.8},\n    mixing_rule=\"geometric\"\n)\n</code></pre>"},{"location":"potentials/multi-lj/#custom-cross-interactions","title":"Custom Cross-Interactions","text":"<p>Override mixing rules for specific pairs:</p> <pre><code>calculator = MultiLennardJones(\n    epsilon={\"A\": 1.0, \"B\": 1.5},\n    sigma={\"A\": 1.0, \"B\": 0.88},\n    mixing_rule=\"lorentz_berthelot\",\n    cross_interactions={\n        (\"A\", \"B\"): {\"sigma\": 0.8, \"epsilon\": 1.5}\n    }\n)\n</code></pre>"},{"location":"potentials/multi-lj/#cutoff-methods","title":"Cutoff Methods","text":""},{"location":"potentials/multi-lj/#shifted-cutoff-default","title":"Shifted Cutoff (Default)","text":"<p>Simple shift to make energy continuous:</p> \\[ u_{\\text{shifted}}(r) = u(r) - u(r_c) \\] <pre><code>calculator = MultiLennardJones(\n    epsilon=1.0,\n    sigma=3.4,\n    rc=10.0,\n    smooth=False  # Default\n)\n</code></pre>"},{"location":"potentials/multi-lj/#smooth-cutoff","title":"Smooth Cutoff","text":"<p>Smoothly goes to zero between <code>ro</code> and <code>rc</code>:</p> \\[ u_{\\text{smooth}}(r) = u(r) \\times S(r) \\] <p>where \\(S(r)\\) is a switching function:</p> \\[ S(r) = \\begin{cases} 1 &amp; r &lt; r_o \\\\ \\frac{(r_c - r)^2(r_c + 2r - 3r_o)}{(r_c - r_o)^3} &amp; r_o \\leq r &lt; r_c \\\\ 0 &amp; r \\geq r_c \\end{cases} \\] <pre><code>calculator = MultiLennardJones(\n    epsilon=1.0,\n    sigma=3.4,\n    rc=10.0,\n    ro=6.6,      # Onset of cutoff\n    smooth=True\n)\n</code></pre>"},{"location":"potentials/multi-lj/#examples","title":"Examples","text":""},{"location":"potentials/multi-lj/#argon-noble-gas","title":"Argon (Noble Gas)","text":"<pre><code>from ase.lattice.cubic import FaceCubicFactory\nfrom a2c_ase.potentials.mlj import MultiLennardJones\n\n# Argon parameters (from literature)\ncalc = MultiLennardJones(\n    epsilon=0.0103,  # eV (0.0103 eV \u2248 120 K)\n    sigma=3.405,     # \u00c5\n    rc=10.0\n)\n\n# Create FCC lattice\natoms = FaceCubicFactory()(symbol='Ar', size=(3,3,3), latticeconstant=5.26)\natoms.calc = calc\n\nenergy = atoms.get_potential_energy()\nprint(f\"Energy per atom: {energy/len(atoms):.4f} eV\")\n</code></pre>"},{"location":"potentials/multi-lj/#kob-andersen-binary-mixture","title":"Kob-Andersen Binary Mixture","text":"<p>Classic binary LJ mixture:</p> <pre><code>calc = MultiLennardJones(\n    epsilon={\"A\": 1.0, \"B\": 0.5},\n    sigma={\"A\": 1.0, \"B\": 0.88},\n    mixing_rule=\"lorentz_berthelot\",\n    cross_interactions={\n        (\"A\", \"B\"): {\"sigma\": 0.8, \"epsilon\": 1.5}\n    },\n    rc=3.0,\n    smooth=True\n)\n</code></pre>"},{"location":"potentials/multi-lj/#see-also","title":"See Also","text":"<ul> <li>Soft Sphere Potential</li> <li>Potentials Overview</li> <li>Workflow Overview</li> <li>API Reference</li> </ul>"},{"location":"potentials/overview/","title":"Potentials Overview","text":"<p><code>a2c_ase</code> includes built-in implementations of classical interatomic potentials that can be used for testing, development, and certain production workflows.</p>"},{"location":"potentials/overview/#available-potentials","title":"Available Potentials","text":""},{"location":"potentials/overview/#soft-sphere","title":"Soft Sphere","text":"<p>A simple repulsive potential useful for initial packing optimization</p> <p>Learn more \u2192</p>"},{"location":"potentials/overview/#multi-species-lennard-jones","title":"Multi-Species Lennard-Jones","text":"<p>Lennard-Jones potential with support for binary and multi-component systems.</p> <p>Learn more \u2192</p>"},{"location":"potentials/overview/#using-external-calculators","title":"Using External Calculators","text":""},{"location":"potentials/overview/#mace","title":"MACE","text":"<pre><code>from mace.calculators.foundations_models import mace_mp\n\ncalculator = mace_mp(\n    model=\"medium\",\n    device=\"cuda\",\n    dtype=\"float32\"\n)\n</code></pre>"},{"location":"potentials/overview/#next-steps","title":"Next Steps","text":"<ul> <li>Soft Sphere Potential</li> <li>Multi-Lennard-Jones Potential</li> <li>API Reference</li> </ul>"},{"location":"potentials/soft-sphere/","title":"Soft Sphere Potential","text":"<p>The soft sphere potential is a simple repulsive interaction used primarily for structure generation and packing optimization.</p>"},{"location":"potentials/soft-sphere/#theory","title":"Theory","text":""},{"location":"potentials/soft-sphere/#potential-form","title":"Potential Form","text":"<p>The pairwise energy between atoms \\(i\\) and \\(j\\) is:</p> \\[ u_{ij}(r) = \\begin{cases} \\frac{\\epsilon}{\\alpha} \\left(1 - \\frac{r_{ij}}{\\sigma}\\right)^\\alpha &amp; \\text{if } r_{ij} &lt; \\sigma \\\\ 0 &amp; \\text{if } r_{ij} \\geq \\sigma \\end{cases} \\] <p>Where:</p> <ul> <li>\\(r_{ij}\\): Distance between atoms \\(i\\) and \\(j\\)</li> <li>\\(\\sigma\\): Particle diameter (cutoff distance)</li> <li>\\(\\epsilon\\): Energy scale</li> <li>\\(\\alpha\\): Stiffness exponent</li> </ul>"},{"location":"potentials/soft-sphere/#force","title":"Force","text":"<p>The force is derived from the potential:</p> \\[ \\mathbf{F}_{ij} = -\\nabla u_{ij} = -\\frac{\\epsilon}{\\sigma} \\left(1 - \\frac{r_{ij}}{\\sigma}\\right)^{\\alpha-1} \\frac{\\mathbf{r}_{ij}}{r_{ij}} \\] <p>for \\(r_{ij} &lt; \\sigma\\), and \\(\\mathbf{F}_{ij} = 0\\) otherwise.</p>"},{"location":"potentials/soft-sphere/#usage","title":"Usage","text":""},{"location":"potentials/soft-sphere/#basic-example","title":"Basic Example","text":"<pre><code>from a2c_ase.potentials.soft_sphere import SoftSphere\nfrom ase import Atoms\nimport numpy as np\n\n# Create atoms\natoms = Atoms(\n    'Si8',\n    positions=np.random.random((8, 3)) * 10,\n    cell=[10, 10, 10],\n    pbc=True\n)\n\n# Create calculator\ncalculator = SoftSphere(\n    sigma=2.5,      # Particle diameter (\u00c5)\n    epsilon=1.0,    # Energy scale (eV)\n    alpha=2,        # Stiffness exponent\n    skin=0.2       # Neighbor list skin\n)\n\n# Attach and compute\natoms.calc = calculator\nenergy = atoms.get_potential_energy()\nforces = atoms.get_forces()\n</code></pre>"},{"location":"potentials/soft-sphere/#parameters","title":"Parameters","text":"Parameter Type Default Description <code>sigma</code> float 1.0 Particle diameter (\u00c5) <code>epsilon</code> float 1.0 Energy scale (eV) <code>alpha</code> int 2 Stiffness exponent <code>skin</code> float 0.2 Neighbor list skin (\u00c5)"},{"location":"potentials/soft-sphere/#see-also","title":"See Also","text":"<ul> <li>Multi-Lennard-Jones Potential</li> <li>Workflow Overview</li> <li>API Reference</li> </ul>"},{"location":"user-guide/workflow/","title":"Workflow Overview","text":"<p>The amorphous-to-crystalline (a2c) workflow predicts crystalline structures that emerge from amorphous precursors.</p>"},{"location":"user-guide/workflow/#workflow-diagram","title":"Workflow Diagram","text":"<pre><code>graph LR\n    A[Random&lt;br/&gt;Structure] --&gt; B[Melt-Quench&lt;br/&gt;MD]\n    B --&gt; C[Subcell&lt;br/&gt;Extraction]\n    C --&gt; D[Structure&lt;br/&gt;Optimization]\n    D --&gt; E[Analysis]</code></pre>"},{"location":"user-guide/workflow/#five-stages","title":"Five Stages","text":""},{"location":"user-guide/workflow/#1-initial-structure-generation","title":"1. Initial Structure Generation","text":"<p>Generate a random atomic configuration with desired composition.</p> <p>Function: <code>random_packed_structure()</code></p> <p>Purpose: Create physically reasonable starting point with no severe atomic overlaps</p> <p>Key parameters: - <code>composition</code>: Chemical formula (e.g., \"Si64\") - <code>cell</code>: 3\u00d73 unit cell matrix (\u00c5) - <code>auto_diameter</code>: Auto-calculate atomic radii - <code>seed</code>: Random seed for reproducibility</p>"},{"location":"user-guide/workflow/#2-melt-quench-molecular-dynamics","title":"2. Melt-Quench Molecular Dynamics","text":"<p>Create amorphous structure through thermal cycling.</p> <p>Function: <code>melt_quench_md()</code></p> <p>Three phases:</p> <ol> <li>High-T Equilibration: Melt the structure</li> <li>Linear Cooling: Quench to trap amorphous state</li> <li>Low-T Equilibration: Relax at target temperature</li> </ol> <p>Key parameters: - <code>T_high</code>: Melting temperature (typically 1.5-2x melting point) - <code>T_low</code>: Target temperature (e.g., 300K) - <code>equi_steps</code>, <code>cool_steps</code>, <code>final_steps</code>: Duration of each phase - <code>time_step</code>: Integration timestep (fs) - <code>friction</code>: Langevin thermostat friction</p> <p>Temperature Selection</p> <p>Choose T_high above the material's melting point to ensure complete melting</p>"},{"location":"user-guide/workflow/#3-subcell-extraction","title":"3. Subcell Extraction","text":"<p>Divide amorphous structure into overlapping regions.</p> <p>Function: <code>extract_crystallizable_subcells()</code></p> <p>Method: Regular grid in fractional coordinates</p> <p>Key parameters: - <code>d_frac</code>: Grid spacing (0.2 = 20% of cell) - <code>n_min</code>, <code>n_max</code>: Atom count range (e.g., 2-8) - <code>cubic_only</code>: Restrict to cubic subcells - <code>allowed_atom_counts</code>: Specific atom counts</p> <p>Performance</p> <p>Smaller <code>d_frac</code> creates more subcells. Use 0.2-0.33 for good balance.</p>"},{"location":"user-guide/workflow/#4-structure-optimization","title":"4. Structure Optimization","text":"<p>Relax each subcell to find stable crystal structures.</p> <p>Function: <code>relax_unit_cell()</code></p> <p>Method: FIRE algorithm with FrechetCellFilter</p> <p>Optimizes: - Atomic positions - Cell shape and volume</p> <p>Key parameters: - <code>max_iter</code>: Maximum optimization steps (e.g., 200) - <code>fmax</code>: Force convergence criterion (eV/\u00c5)</p>"},{"location":"user-guide/workflow/#5-validation-and-analysis","title":"5. Validation and Analysis","text":"<p>Identify and rank stable structures.</p> <p>Validation: <code>valid_subcell()</code> - Energy decreased during optimization - Formation energy physically reasonable - No atomic fusion (atoms too close) - Forces converged</p> <p>Analysis: Using pymatgen - Determine space group with <code>SpacegroupAnalyzer</code> - Compare to reference structures with <code>StructureMatcher</code> - Rank by energy per atom</p>"},{"location":"user-guide/workflow/#complete-example","title":"Complete Example","text":"<p>Full working implementation: <code>example/Si64.py</code></p>"},{"location":"user-guide/workflow/#performance","title":"Performance","text":"Stage Bottleneck Solution Random packing Overlap removal Increase diameter Melt-quench MD steps Reduce steps for testing Subcell extraction Too many subcells Increase d_frac Optimization Force calculations Use GPU, parallelize"},{"location":"user-guide/workflow/#see-also","title":"See Also","text":"<ul> <li>Examples</li> <li>API Reference</li> <li>Quick Start</li> </ul>"}]}